(()=>{"use strict";var __webpack_modules__={523:()=>{eval("\n;// ./src/modules/logic/Ship.js\nclass Ship{\n    #length = 0;\n    #damage = 0;\n    #positions =[];\n    #isSunk = false;\n    constructor(length, name){\n        this.#length = length;\n        this.name = name;\n\n    }\n    //get\n    getLength = () =>{\n        return this.#length;\n    };\n    getDamage = () =>{\n        return this.#damage;\n    };\n    getIsSunk = () =>{\n        return this.#isSunk;\n    };\n    getPositions(){\n        return this.#positions;\n    };\n    //set\n    setPosition(pos){\n        this.#positions.push(pos);\n        \n    };\n    resetPositions(){\n        this.#positions = [];\n    }\n    hit = ([y, x], hit) =>{\n        this.#damage = this.#damage + hit;\n        this.#sinkShip();\n    }\n    #sinkShip = () =>{\n        if(!this.#isSunk && this.#damage === this.#length) this.#isSunk = true;\n\n    }\n    resatShip(){\n        this.#length = 0;\n        this.#damage = 0;\n        this.#positions = [];\n        this.#isSunk = false;\n        this.name = '';\n    }\n    \n\n}\n\n\n;// ./src/modules/logic/Gameboard.js\n\nclass Gameboard{\n    //init grid \n    grid = [];\n\n    constructor(){\n        this.grid = Array.from({ length: 10 }, () => Array(10).fill(null));\n    }\n\n    populateGrid([x, y], shipLength, name, direction = \"horizontal\"){\n        \n        if (x < 0 || y < 0 || x >= this.grid.length || y >= this.grid.length) {\n            throw new Error('Starting position out of bounds!');\n        } \n        const ship = new Ship(shipLength, name)      \n\n        if(direction === \"horizontal\"){\n            if(x + shipLength> this.grid.length) throw new Error('ship out of bounds horizontally');\n            for(let i = 0; i < shipLength; i++){\n                if(this.grid[y][x+i]!== null)throw new Error('Position occupied');\n            } \n            for(let i = 0;i <shipLength; i++){\n                this.grid[y][x + i]= ship;\n                ship.setPosition([y, x+ i])\n            }  \n\n        }\n        if(direction === \"vertical\"){\n            if(y+ shipLength > this.grid.length)throw new Error('ship out of bounds vertically');\n            for(let i = 0; i < shipLength; i++){\n                if(this.grid[y+ i][x]!== null) throw new Error('Position occupied');\n            }\n            for(let i = 0; i < shipLength; i++){\n                this.grid[y+i][x]= ship;\n                ship.setPosition([y + i, x])\n            }\n        } \n    }\n    clearGrid(){\n        \n        if(this.grid !== null){\n            this.grid.forEach(row =>{\n                row.forEach(col=>{\n                    if(col instanceof Ship){\n                        col.resatShip();\n                        col = null;\n                    }\n                    col = null;\n                })\n            })\n        }\n    }\n    //if coordinate is null meaning no ship,\n    // - set coordinate to false indicating the coordinate is no longer an option;\n    recieveAttack([x, y]){\n        const cell = this.grid[y][x];\n        if(cell === null){\n            this.grid[y][x] = false;\n            return false\n        }else  if(cell instanceof Ship){\n            cell.hit([y, x], 1);\n            this.grid[y][x] = \"hit\";\n            return true;\n        }\n    }\n    //returns false if atleast one ship is still afloat returns true if all ships are sunk\n    allShipsSunk(){\n        let allSunk= true;\n        this.grid.forEach(row =>{\n            row.forEach(cell=>{\n                if(cell instanceof Ship && !cell.getIsSunk())allSunk = false ;\n                \n            })\n        })\n        return allSunk;\n    }\n    getGrid = () =>{\n        return this.grid;\n    }\n}\n\n;// ./src/modules/logic/Player.js\n\n\n\nclass Player{\n    #isAi =false\n    constructor(enableAi){\n        this.gameboard= new Gameboard();\n        this.#isAi= enableAi\n    }\n    isComputer(){\n        if(this.#isAi) return true;\n        else return false;\n    }\n    genFleet(){\n        if(this.#isAi){\n            const fleet = [\n                { name: 'Carrier', length: 5 },\n                { name: 'Battleship', length: 4 },\n                { name: 'Cruiser', length: 3 },\n                { name: 'Submarine', length: 3 },\n                { name: 'Destroyer', length: 2 }, \n            ];\n            fleet.forEach(ship =>{\n                let placed = false;\n                while(!placed){\n                    const direction = Math.random() > 0.5 ? 'horizontal' : 'vertical';\n                    const x = Math.floor(Math.random()* 10);\n                    const y = Math.floor(Math.random()* 10);\n                    try{\n                        this.gameboard.populateGrid([x, y], ship.length, ship.name, direction);\n                        placed = true\n                    }catch(error){\n                        \n                    }\n                }\n            })\n        }\n    }\n    aiAttack(opponent,){\n        let x, y;\n        do{\n            x = Math.floor(Math.random()* 10);\n            y = Math.floor(Math.random()* 10);\n        }while(this.#isCellShotAt(opponent.gameboard.getGrid(), x, y)){            \n            const hitStatus = opponent.gameboard.recieveAttack([x, y]);\n\n            return {hit: hitStatus, x , y};\n\n        }\n    }\n    #isCellShotAt(board, x, y){\n        const cell = board[y][x];\n        return cell === false || cell === \"hit\" ;\n    }\n    //attempt at a smarter ai (not required for the project)\n    #huntShip(x, y, opponent){\n        const nearByCells = [\n            [x, y -1],\n            [x, y + 1],\n            [x -1 , y],\n            [x + 1, y]\n        ]\n        let validCells = [];\n        nearByCells.forEach(cell=>{\n            const [newX,newY] = cell;\n            if (newX >= 0 && newX < 10 && newY >= 0 && newY < 10) {\n                // Check if the cell is either a miss (false) or \"hit\" (already attacked)\n                const cellStatus = opponent.gameboard.getGrid()[newY][newX];\n                if (cellStatus !== false && cellStatus !== \"hit\") {\n                    validCells.push([newX, newY]);\n                }\n            }\n        })\n        if (validCells.length > 0){\n            const randomIndex = Math.floor(Math.random() * validCells.length);\n            const [targetX, targetY] = validCells[randomIndex];\n            console.log( `valid next moves: ${validCells}`);\n            return{targetX, targetY};\n   \n        }\n        return null;\n\n    }\n}\n\n\n;// ./src/modules/dom/mainContainer.js\n\nconst body = document.body;\n\n//maincontainer\nconst container = document.createElement('div');\ncontainer.classList.add('main-container');\ncontainer.style.gridArea = 'main';\ncontainer.style.display = 'grid';\n\ncontainer.style.gap = \"2px\";\n//container.style.backgroundColor = \"#ddddddff\";\n\n//gametitle\nconst playerTitle = document.createElement('dev');\nplayerTitle.style.gridArea = 'title';\nplayerTitle.innerHTML = 'Battleship.';\nplayerTitle.style.fontSize = \"64px\";\nplayerTitle.style.alignSelf = \"center\";\nplayerTitle.style.justifySelf = \"center\";\n\nbody.style.gridTemplateAreas= `\n'. title .'\n'main main main'\n'. . .' `;\nbody.appendChild(playerTitle);\nbody.appendChild(container);\n\n\n \n;// ./src/modules/dom/grid.js\n\nconst createBoard =(boardId)=>{\n    const grid = document.createElement('div');\n    grid.style.width = \"500px\";\n    grid.style.height = \"500px\"\n\n    grid.style.display = \"grid\";\n    grid.id =boardId;\n    grid.style.gap = \"2px\";\n    grid.style.padding = \"2px\"\n    grid.style.backgroundColor= \"#b1cac9ff\";\n    grid.style.gridTemplateColumns = 'repeat(10, 1fr)';\n    grid.style.gridTemplateRows = 'repeat(10, 1fr)';\n    const cells = [];\n    for(let x = 0; x <10 ; x++){\n        for(let y = 0; y < 10; y++){\n            const cell = document.createElement('div');\n            cell.setAttribute(\"id\",`${y},${x}`);  \n            cell.textContent = \"  \";\n            cell.classList.add('cell');\n            cell.style.backgroundColor = 'white';\n\n            cell.dataset.x = x;\n            cell.dataset.y = y;\n            cells.push(cell);\n            grid.appendChild(cell);\n        }\n    }\n    return {grid, cells};\n}\n\n\n;// ./src/modules/dom/fleetSelect.js\n\n//name: 'Carrier', length: 5 \n//name: 'Battleship', length: 4 \n//name: 'Cruiser', length: 3 \n//name: 'Submarine', length: 3 \n//name: 'Destroyer', length: 2 \nlet selectedShip = null;\nlet orientation = \"horizontal\";\nconst carrier =document.createElement(\"div\");\ncarrier.innerHTML='Carrier';\ncarrier.id = 'Carrier';\ncarrier.className = \"in-button\";\ncarrier.classList.add('ship-btn');\ncarrier.addEventListener('click',()=>{\n    selectedShip = carrier.id;\n    console.log(`selected ship set to:${selectedShip} `)\n})\n\n\nconst battleShip =document.createElement(\"div\");\nbattleShip.innerHTML='Battleship';\nbattleShip.id = 'Battleship';\nbattleShip.className = \"in-button\";\nbattleShip.classList.add('ship-btn');\nbattleShip.addEventListener('click',()=>{\n    selectedShip = battleShip.id;\n    console.log(`selected ship set to:${selectedShip} `)\n})\n\nconst cruiser =document.createElement(\"div\");\ncruiser.innerHTML='Cruiser';\ncruiser.id = 'Cruiser';\ncruiser.className = \"in-button\";\ncruiser.classList.add('ship-btn');\ncruiser.addEventListener('click',()=>{\n    selectedShip = cruiser.id;\n    console.log(`selected ship set to:${selectedShip} `)\n})\n\nconst submarine =document.createElement(\"div\");\nsubmarine.innerHTML='Submarine';\nsubmarine.id = 'Submarine';\nsubmarine.className = \"in-button\";\nsubmarine.classList.add('ship-btn');\nsubmarine.addEventListener('click',()=>{\n    selectedShip = submarine.id;\n    console.log(`selected ship set to:${selectedShip} `)\n})\n\nconst destroyer =document.createElement(\"div\");\ndestroyer.innerHTML='Destroyer';\ndestroyer.id = 'Destroyer';\ndestroyer.className = \"in-button\";\ndestroyer.classList.add('ship-btn');\ndestroyer.addEventListener('click',()=>{\n    selectedShip = destroyer.id;\n    console.log(`selected ship set to:${selectedShip} `)    \n})\nconst direction = document.createElement(\"div\");\ndirection.className = \"in-button\";\ndirection.style.backgroundColor = \"#ff8383ff\";\ndirection.innerHTML = orientation;\ndirection.addEventListener(\"click\",()=>{\n    if(orientation === \"horizontal\"){\n        orientation = \"vertical\";   \n        direction.style.backgroundColor = \"#99ec8fff\"; \n    }else{\n        orientation = \"horizontal\";\n        direction.style.backgroundColor = \"#ff8383ff\";\n    }\n    direction.innerHTML = orientation\n})\n\n\n\n;// ./src/modules/dom/setFleet.js\n\n\n\n\nconst view = document.createElement('div');\nview.style.display = \"none\";\nview.classList.add('fleet-view')\n\nconst fleetCont = document.createElement('div');\nfleetCont.classList.add('ship-Btns');\nfleetCont.style.gridArea = 'choices';\nfleetCont.style.alignContent = \"center\";\nfleetCont.style.justifyContent = \"center\";\n\nview.style.alignSelf = \"center\";\nview.style.justifySelf = \"center\";\nview.style.justifyItems = 'center';\nview.style.alignItems = 'center';\n\nview.style.display = \"grid\";\nview.style.height = '100%';\nview.style.width = '100%';\nview.style.gridTemplateColumns = \"1fr 2fr 1fr\";\nview.style.gridTemplateRows = \"1fr 4fr 1fr\";\n\nview.style.gridTemplateAreas = `\n\". title .\"\n\"choices gridA .\"\n\". next  .\"`\n\nconst title = document.createElement('div');\ntitle.style.gridArea = \"title\";\ntitle.innerHTML = \"position your fleet\";\ntitle.style.alignSelf = \"center\";\ntitle.style.justifySelf = \"center\";\nconst {grid, cells} = createBoard('playerA');\ngrid.style.gridArea= \"gridA\";\n\n\nview.appendChild(fleetCont);\nview.appendChild(grid);\nview.appendChild(title);\n\n\nfleetCont.appendChild(carrier);\nfleetCont.appendChild(battleShip);\nfleetCont.appendChild(cruiser);\nfleetCont.appendChild(submarine);\nfleetCont.appendChild(destroyer);\nfleetCont.appendChild(direction);\n\n\n;// ./src/modules/dom/nextstageBtn.js\n\nconst createNextBtn=(label, parent)=>{\n    const btn = document.createElement('div');\n    btn.innerHTML = label;\n    btn.style.gridArea= \"next\";\n    btn.className = \"in-button\";\n    btn.id = \"next\"; \n    parent.appendChild(btn);\n    return btn  \n}\n\n\n;// ./src/modules/fleetSetup.js\n\n\n\n//import grids\n\n\n\n//progress button\nconst next =createNextBtn('nextstage', view);\nnext.style.display = 'none';\n\n//grid ui handlers\nconst syncGrid = (playerGrid )=>{\n    gridSyncRester()\n\n    playerGrid.forEach((logicRow, yIndex) =>{\n        logicRow.forEach((logicCell, xIndex) =>{\n            if(logicCell instanceof Ship){\n                //get dom cells\n                const logicCellId = `${xIndex},${yIndex}`                \n                const cells = grid.querySelectorAll('.cell');\n\n                //check ship placement in the gameboard 2Darray\n                \n                cells.forEach(cell=>{\n                    if(cell.id === logicCellId){\n                        //console.log(cell.id);\n                        cell.style.backgroundColor = \"#6cf1e6ff\";\n                    }\n                })\n            }\n            return\n        })\n    })\n\n}\nconst gridSyncRester = ()=>{\n    const cells = grid.querySelectorAll('.cell');\n    cells.forEach(cell=>{\n        cell.style.backgroundColor = \"#ffffffff\";\n    })\n}\n\n//cell listeners\nconst addEventListenerTocells = (player)=>{\n\n    const cells = grid.querySelectorAll('.cell');\n\n    cells.forEach(cell =>{\n        cell.addEventListener(`click`,(e)=>{\n            const clickedId = e.target.id;\n            handleCellClick(clickedId, player);\n        })\n        cell.addEventListener('mouseover',(e)=>{\n            const[row, col]= e.target.id.split(',').map(Number)\n            ;            \n            if(selectedShip && !movingship){\n                const ship = getShipByName(selectedShip);\n                highlightPreview(player, row, col, ship.length, orientation);\n            }\n            if(movingship){\n                highlightPreview(player, row, col, movingship.getLength(), orientation);\n            }\n        })\n        cell.addEventListener(\"mouseout\",()=>{\n            resetPreview();\n        })\n    })\n}\nlet placedShips = [];\nlet movingship = null;\n//handles click\nconst handleCellClick = (id, player)=>{\n    const[row, col] = id.split(',').map(Number);\n    const grid = player.gameboard.getGrid();\n    const cellData =grid[col][row];\n\n    //no ship selected, no ship moving currently\n    if(!selectedShip && !movingship) return;\n\n    //handels ship selection for movement\n    if(cellData instanceof Ship && !movingship){\n        movingship = cellData;\n        //console.log(`selected ship to move: ${movingship.name}`);\n        return;\n    }\n    //handels an already moving ship\n    if(movingship){\n        try{\n            \n            shipMoveHandler(player, movingship, row, col, orientation);\n            movingship = null;\n            syncGrid(grid);\n            console.log(`ship moved successfully.`);\n    \n        }catch{\n            console.error(`Cannot move ship `);\n        }\n    }\n    //prevents duplicates\n    if(placedShips.includes(selectedShip)){\n        console.log(`Ship \"${selectedShip}\" already placed.`);\n        return;\n    }else{\n        const ship = getShipByName(selectedShip);\n        player.gameboard.populateGrid([row,col], ship.length, selectedShip, orientation);\n        placedShips.push(selectedShip);\n        syncGrid(grid);\n\n        //disable the ship btn in ui\n        const shipDiv = document.getElementById(selectedShip);\n        shipDiv.style.pointerEvents = 'none';\n        shipDiv.style.opacity = '0.5';  \n    }\n    //check if all ships are placed\n    if(placedShips.length === 5){\n        next.style.display = 'block';\n\n    }\n}\nconst getShipByName = (shipName)=>{\n    const fleet = [\n        { name: 'Carrier', length: 5 },\n        { name: 'Battleship', length: 4 },\n        { name: 'Cruiser', length: 3 },\n        { name: 'Submarine', length: 3 },\n        { name: 'Destroyer', length: 2 }, \n    ];\n    return fleet.find(ship=>ship.name === shipName);\n}\nconst shipMoveHandler=(player, ship, newStartX, newStartY, direction)=>{\n        ship.getPositions().forEach(([y, x])=>{\n            player.gameboard.grid[y][x]= null;\n        });\n        ship.resetPositions();\n        player.gameboard.populateGrid([newStartX,newStartY], ship.getLength(), ship.name, direction);\n        syncGrid(player.gameboard.getGrid());\n\n    }\n//handels prieview\nconst highlightPreview = (player, startR, startC, length, direction)=>{\n    resetPreview();\n    const cells = grid.querySelectorAll('.cell');\n    for (let i = 0; i < length; i++) {\n        let row = startR;\n        let col = startC;\n\n        if (direction === 'horizontal') row += i;\n        if (direction === 'vertical') col += i;\n\n        const cell = Array.from(cells).find(c => c.id === `${row},${col}`);\n        if (cell) {\n            cell.dataset.preview = 'true';\n            cell.style.outline = '2px solid #00bfff'; \n            cell.style.shadowBox = \"0px 0px 40px -10px #00bfff\"\n            cell.style.outlineOffset = '-2px';\n        }\n    }\n\n}\nconst resetPreview=()=>{\n    const cells = grid.querySelectorAll('.cell');\n\n    cells.forEach(cell => {\n        if (cell.dataset.preview) {\n            cell.style.shadowBox = 'none'\n            cell.style.outline = 'none';\n            delete cell.dataset.preview;\n        }\n    });\n}\nconst resetFleet = ()=>{\n    placedShips = [];\n    movingship = null;\n    gridSyncRester();\n    const shipButtons = document.querySelectorAll('.ship-btn');\n    shipButtons.forEach(button =>{\n        button.pointerEvents = 'auto';\n        button.style.opacity = '1';\n    })\n    if(view.contains(next)){\n        next.style.display = 'none';\n    }\n}\n\n\n;// ./src/modules/dom/preInit.js\nlet gameMode = null;\nconst preInit_view = document.createElement('div');\npreInit_view.style.display = \"none\";\npreInit_view.style.alignSelf = \"center\";\npreInit_view.style.justifySelf = \"center\";\npreInit_view.style.display = \"grid\";\npreInit_view.style.height = '100%';\npreInit_view.style.width = '100%';\npreInit_view.style.gridTemplateColumns = \"repeat(4 , 1fr)\";\npreInit_view.style.gridTemplateRows = \"1fr 1fr\";\n\npreInit_view.style.gridTemplateAreas = `\n\". title title .\"\n\". pvp pvnpc .\"`\n\nconst preInit_title = document.createElement('div');\npreInit_title.innerHTML = \"choose game mode\";\npreInit_title.style.gridArea = \"title\";\npreInit_title.style.alignSelf = \"center\";\npreInit_title.style.justifySelf=\"center\";\n\nconst pvp = document.createElement('div');\npvp.innerHTML = \"Player vs. Player\";\npvp.id = 'pvp';\npvp.style.gridArea= \"pvp\";\npvp.style.justifySelf = \"center\";\npvp.className = \"in-button\";\npvp.style.pointerEvents = 'none';\npvp.style.opacity = '0.5';\n\nconst pvnpc = document.createElement('div');\npvnpc.innerHTML = \"Player vs. Computer\";\npvnpc.id = 'pvnpc';\npvnpc.style.gridArea=\"pvnpc\";\npvnpc.style.justifySelf = \"center\";\npvnpc.className = \"in-button\";\n\n\n\npreInit_view.appendChild(preInit_title);\npreInit_view.appendChild(pvp);\npreInit_view.appendChild(pvnpc);\n\n\n\n\n;// ./src/modules/stages/menuStage.js\n\n\n\nconst showMenu = () =>{\n    return new Promise(resolve=>{\n        container.appendChild(preInit_view);\n        preInit_view.style.display= 'grid';\n\n        const modeSelection = (mode)=>{\n            preInit_view.style.display = 'none';\n            resolve(mode);\n        }\n        document.getElementById('pvp').addEventListener('click', ()=>{\n            console.log('pvp');\n            modeSelection('pvp')\n        });\n        document.getElementById('pvnpc').addEventListener('click', ()=>{\n            console.log(`pvnpc`)\n            modeSelection('pvnpc')\n        });\n    })\n}\n\n\n;// ./src/modules/stages/fleetSetupStage.js\n\n\n\n\nconst fleetPlacement = async (playerA,playerB, mode)=>{\n    return new Promise(async resolve => {    \n        container.appendChild(view);\n        view.style.display = 'grid';\n\n        if(mode === 'pvnpc'){\n            resetFleet();\n            playerB.genFleet();\n            await setupPlayerFleet(playerA, 'Finalize player A');\n            view.style.display = 'none';\n        };\n        if(mode === 'pvp'){\n            resetFleet();\n            await setupPlayerFleet(playerA, 'Finalize player A');\n            resetFleet();\n            await setupPlayerFleet(playerB, 'Finalize player B');\n            view.style.display = 'none';\n        };\n        resolve();\n    });\n};\nconst setupPlayerFleet = async (player, nextBtn)=>{\n    return new Promise(resolve =>{\n        addEventListenerTocells(player);\n        next.innerHTML = nextBtn;\n\n        if(!view.contains(next)){\n            view.appendChild(next);\n        }\n\n        next.addEventListener('click',()=>{\n            console.log(`next button has been clicked!`);\n            resolve();\n        },{once:true});\n      \n    })\n}\n \n;// ./src/modules/dom/Attack.js\n\nconst Attack_view = document.createElement('div');\nAttack_view.style.display = \"none\";\nAttack_view.style.alignSelf = \"center\";\nAttack_view.style.justifySelf = \"center\";\nAttack_view.style.display = \"grid\";\nAttack_view.style.height = '100%';\nAttack_view.style.width = '100%';\nAttack_view.style.gridTemplateColumns = \"1fr  1fr\";\nAttack_view.style.gridTemplateRows = \"1fr 4fr 1fr\";\nAttack_view.style.gridTemplateAreas = `\n\"title   title \"\n\" containerA containerB \"\n\"containerA containerB  \"`\n\nconst Attack_title = document.createElement('div');\nAttack_title.style.gridArea = \"title\";\n//title.innerHTML = \"coordinate attack!\";\nAttack_title.style.alignSelf = \"center\";\nAttack_title.style.justifySelf = \"center\";\n\n//create gridA and grid B\nconst {grid : gridA,cells : cellsA} = createBoard('playerA');\nconst {grid : gridB,cells : cellsB }= createBoard('playerB');\n\ngridA.style.gridArea = 'gridA';\ngridB.style.gridArea ='gridB';\n//grid A container\nconst gridAContainer = document.createElement('div');\ngridAContainer.style.display = 'grid';\ngridAContainer.style.gridTemplateColumns = \"1fr\";\ngridAContainer.style.gridTemplateRows = \"1fr 6fr\";\ngridAContainer.style.gridTemplateAreas = `\n\"gridNameA \"\n\" gridA \"`\ngridAContainer.style.gridArea = 'containerA';\n// grid A name\nconst gridAName = document.createElement('div');\ngridAName.innerHTML = gridA.id;\ngridAName.style.gridArea = 'gridNameA';\ngridAName.style.alignSelf = 'center';\ngridAName.style.justifySelf = 'center';\n//centering container title and board\n//title\ngridAName.style.alignItems = 'center';\ngridAName.style.justifyItems = 'center';\n//board\ngridAContainer.style.alignItems = 'center';\ngridAContainer.style.justifyItems = 'center';\n\ngridAContainer.appendChild(gridAName)\ngridAContainer.appendChild(gridA)\n\n//grid B container\nconst gridBContainer = document.createElement('div');\ngridBContainer.style.display = 'grid';\ngridBContainer.style.gridTemplateColumns = \"1fr\";\ngridBContainer.style.gridTemplateRows = \"1fr 6fr\";\ngridBContainer.style.gridTemplateAreas = `\n\"gridNameB \"\n\" gridB \"`\ngridBContainer.style.gridArea = 'containerB';\n// grid b name\nconst gridBName = document.createElement('div');\ngridBName.innerHTML = gridB.id;\ngridBName.style.gridArea = 'gridNameB';\ngridBName.style.alignSelf = 'center';\ngridBName.style.justifySelf = 'center';\n//centering container title and board\n//title\ngridBName.style.alignItems = 'center';\ngridBName.style.justifyItems = 'center';\n//board\ngridBContainer.style.alignItems = 'center';\ngridBContainer.style.justifyItems = 'center';\n\ngridBContainer.appendChild(gridBName)\ngridBContainer.appendChild(gridB)\n\n\n\n\n\n\nAttack_view.appendChild(gridAContainer);\nAttack_view.appendChild(gridBContainer);\n\n\nAttack_view.appendChild(Attack_title);\n\n\n\n;// ./src/modules/stages/battleStage.js\n\n\n\n\n\n\nconst battle= async (playerA,playerB, mode)=>{\n    container.appendChild(Attack_view);\n\n    \n    if(mode === 'pvnpc'){\n        const winner = await handlePvNpc(playerA, playerB);\n        if(winner){\n            resetGrids(gridA, playerA.gameboard.getGrid());\n            resetGrids(gridB, playerB.gameboard.getGrid());\n            Attack_view.style.display = \"none\";\n            return winner\n            \n        }\n\n    }\n\n}\nconst handlePvNpc = async (playerA, playerB)=>{\n    return new Promise(async resolve =>{\n        Attack_view.style.display = \"grid\";\n        let stage = 'attack';\n        let winner = false;\n        addAttackEventListener(playerB, gridB);\n\n\n        while(!winner){\n            if(stage === 'attack'){\n                //player attacks\n                Attack_title.innerHTML =\"Your turn to attack!\";\n                //gridA.style.outline = \"none\";\n                //gridA.style.outlineOffset = '0px';\n\n\n                //gridB.style.transform= \"scale(1)\";\n                //gridB.style.transition =\"transform 0.2s ease, outline 0.2s ease\";\n                gridA.classList.remove('under-attack');\n                gridB.classList.remove('attacking');\n\n                gridA.classList.add('attacking')\n                gridB.classList.add('under-attack');\n\n                //gridB.style.outline = \"2px solid black\";\n                //gridB.style.outlineOffset = '-2px';\n\n                displayPlayerGrid(playerA.gameboard.getGrid(),gridA);\n\n                toggleEventListener(gridA,playerA.gameboard.getGrid(), 'none');\n                toggleEventListener(gridB,playerB.gameboard.getGrid(), 'auto');\n\n\n                await waitForAttack(gridB, playerB);\n                await new Promise(resolve=> {setTimeout(resolve, 500)}); \n\n                if(playerB.gameboard.allShipsSunk()){\n                    winner = true;\n                    Attack_title.innerHTML =\"you are the winner\";\n                    resolve('PlayerA')\n                }else{\n                    stage = 'observe';  \n                }    \n            }\n            else if(stage === 'observe'){\n\n                //computer attacks\n                Attack_title.innerHTML =\"Computers turn to attack!\";\n                //gridB.style.outline = \"none\";\n                //gridB.style.outlineOffset = '0px';\n                gridB.classList.remove('under-attack');\n                gridA.classList.remove('attacking');\n\n                gridB.classList.add('attacking')\n                gridA.classList.add('under-attack');\n               //gridA.style.outline = \"2px solid black\";\n                //gridA.style.outlineOffset = '-2px';\n\n\n                toggleEventListener(gridA,playerA.gameboard.getGrid(), 'none');\n                toggleEventListener(gridB,playerB.gameboard.getGrid(), 'none');\n\n                await new Promise(resolve=> {setTimeout(resolve, 1000)});\n                await waitComputerAttack(playerB, playerA, gridA) \n                await new Promise(resolve=> {setTimeout(resolve, 500)});  \n\n            if(playerA.gameboard.allShipsSunk()){\n                    winner = true;\n                    Attack_title.innerHTML =\"computer has won\";\n                    resolve('PlayerB')\n                }else{\n                    stage = 'attack';  \n                }    \n            }\n        }\n\n \n    })\n\n}\n//ui updaters\nconst displayPlayerGrid = (playerGrid , uiGameboard)=>{\n    playerGrid.forEach((logicRow, yIndex) =>{\n        logicRow.forEach((logicCell, xIndex) =>{\n            if(logicCell instanceof Ship){\n                //get dom cells          \n                const logicCellId = `${xIndex},${yIndex}`                \n                const cells = uiGameboard.querySelectorAll('.cell');\n                //check ship placement in the gameboard 2Darray\n                cells.forEach(cell=>{\n                    if(cell.id === logicCellId){\n                        if (logicCell === \"hit\"){\n                            cell.style.backgroundColor = 'red'\n                        }else if( logicCell === false){\n                            cell.style.backgroundColor = 'gray'\n                        }else if(logicCell instanceof Ship){\n                            cell.style.backgroundColor = \"#6cf1e6ff\";\n                        }\n                    }\n                })\n            }\n            return\n        })\n    })\n\n}\n//asyncronus attacks\nconst waitForAttack = (grid, player) =>{\n    return new Promise(resolve => {\n        const playerGrid = player.gameboard.grid;\n        const cells = grid.querySelectorAll('.cell');\n  \n        const invalidCells = [];\n        cells.forEach(cell=>{\n            const [y, x] = cell.id.split(',').map(Number);\n            if(playerGrid[x][y] === false || playerGrid[x][y] === 'hit'){\n                invalidCells.push(cell);\n\n            }\n        });\n        function handleCellClick(e){\n            const cell = e.target.closest('.cell');\n            const [y, x] = cell.id.split(',').map(Number);\n\n            invalidCells.push(cell);\n            resolve(cell);\n        }\n        cells.forEach(cell=>{\n            \n            if(!invalidCells.includes(cell) || !cell.hasAttribute('data-listener-added')){         \n\n                cell.addEventListener('click',handleCellClick,{once:true});\n\n            }\n        })\n    })\n}\n//computer attack\nconst waitComputerAttack =async(player, opponent, grid)=>{\n    return new Promise(resolve=> {\n        const { hit, x, y} = player.aiAttack(opponent);\n        const cellId = `${x},${y}`\n        let cell;\n        const cells = grid.querySelectorAll('.cell');\n        cells.forEach(item=>{\n            if (item.id === cellId) {\n                cell = item;\n            }\n        });\n                    \n        if(cell){\n            if(hit){\n\n                cell.style.backgroundColor = \"red\";\n                cell.style.pointerEvents = 'none';\n                cell.style.opacity = '0.5';       \n            }else{\n               \n                cell.style.pointerEvents = 'none';\n                cell.style.opacity ='0.5';\n            }\n        }  else{\n            console.error(`cell with id ${cellId} not found`)\n        } \n        resolve();\n           \n    })\n} \n//handles event listeners\nconst toggleEventListener=(grid,playerGrid, state)=>{\n    const cells = grid.querySelectorAll('.cell');\n\n    cells.forEach(cell=>{\n        const [y, x] = cell.id.split(',').map(Number);\n        \n        if(playerGrid[x][y] === false || playerGrid[x][y] === \"hit\"){\n            cell.style.pointerEvents = 'none';\n            cell.style.opacity = '0.5';\n        }else{\n            cell.style.pointerEvents = state;\n        }\n    })\n\n}\n//appends event listeners to cells\nconst addAttackEventListener = (player, grid)=>{\n    const cells = grid.querySelectorAll('.cell')\n\n    const clickListener = (e) =>{\n        const cell = e.target.closest('.cell');\n        if(!cell) return;\n        clickHandler(player.gameboard, cell)\n\n    }\n\n    cells.forEach(cell =>{\n        if(!cell.hasAttribute('data-listener-added')){\n\n            cell.addEventListener('mouseover',()=>{\n            cell.style.outline = '2px solid green';\n            cell.style.outlineOffset = '-2px';\n                })\n            cell.addEventListener('mouseout',()=>{\n            cell.style.outline = 'none';\n            cell.style.outlineOffset = '0px';\n                })\n            cell.removeEventListener('click', clickListener);\n            cell.addEventListener('click', clickListener,{once:true});\n            cell.setAttribute('data-listener-added', 'true');\n        }\n    })\n\n}\n//handels event listener onclick\nconst clickHandler=(playerGrid,cell)=>{\n \n    const [y, x] = cell.id.split(',').map(Number);\n\n    let hitStatus;\n    if ( Number.isNaN(x) || Number.isNaN(y) || y < 0 || y > 9 || x < 0 || x > 9 ||playerGrid.grid[x][y] === undefined) {\n        console.error(`Invalid coordinates: (${x}, ${y})`);\n        return;\n    }\n    if(playerGrid.grid[x][y] === false || playerGrid.grid[x][y] === 'hit'){\n        console.warn(`Cell (${x}, ${y}) has already been attacked.`);\n        return\n        \n    }\n    \n    if(playerGrid.grid[x][y] instanceof Ship || playerGrid.grid[x][y] === null ){\n        hitStatus =  playerGrid.recieveAttack([y, x]);\n    }\n\n    \n    if(hitStatus){  \n        //hit         \n        cell.style.backgroundColor = \"black\";\n        cell.style.pointerEvents = 'none';\n        cell.style.opacity='0.5';\n                    \n    }else if(!hitStatus){\n        //miss\n        cell.style.pointerEvents = 'none';\n        cell.style.opacity = '0.5';      \n    }\n\n    return\n    \n\n}\n//reseting gamebaord\nconst resetGrids = (grid, playerGrid) =>{\n    const cells = grid.querySelectorAll('.cell');\n    cells.forEach(cell=>{\n        const [y, x] = cell.id.split(',').map(Number);\n        playerGrid[x][y] = null\n        const clone = cell.cloneNode(true);\n        cell.parentNode.replaceChild(clone,cell)\n        cell.style.pointerEvents = 'auto';\n        cell.style.opacity = '1';\n        cell.style.backgroundColor = '';\n    })\n}\n\n\n;// ./src/modules/stages/endGameStage.js\n\n\nconst showEnd = async (winner)=>{\n   return new Promise(resolve => {\n      console.log(`the winner is: ${typeof winner}`);\n      const congrats = document.createElement('div');\n      if(winner === 'PlayerA'){\n         congrats.innerHTML = 'Congratulations you won this round!';\n      }else if(winner === \"PlayerB\"){\n         congrats.innerHTML = 'You died!';\n      }\n      congrats.style.display = 'grid';\n      congrats.style.justifySelf = 'center';\n      congrats.style.alignSelf = 'center';\n      /*\n      const button = document.createElement('div');\n      button.innerHTML= \"New game!\";\n      button.style.justifySelf = 'center';\n      button.style.alignSelf = 'center';\n      button.className = 'in-button';\n      button.addEventListener('click',()=>{\n         congrats.style.display = 'none'\n         button.style.display = 'none';\n         resolve(true)\n      })\n   */\n      container.appendChild(congrats);\n      \n   })\n\n};\n\n\n;// ./src/modules/Play.js\n\n\n\n\n//import grids\n\n\n\n\n\n\n//initiates game and prompts for game mode\nconst gameStart = async ()=>{\n   //==>new implementation<==\n   let playAgain =true;\n   //setsgame mode\n   //global players:\n \n   while(playAgain){\n    let playerA = null;\n    let playerB = null\n    const mode = await showMenu();\n    //fleet setup\n        if(mode === 'pvnpc'){\n            playerA = new Player();\n            playerB = new Player(true);\n            \n        }else if(mode === 'pvp'){\n\n            alert(`currently unavailable`)\n            return\n            \n        }\n        await fleetPlacement(playerA, playerB, mode);\n    \n        //battle loop\n        const winner = await battle(playerA, playerB, mode);\n        //end\n        const newRound = await showEnd(winner);\n\n        //prompt new game\n        playAgain =await newGame(newRound, playerA, playerB);\n    }\n\n}\nconst newGame = async (input, playerA, playerB) =>{\n    if(input){\n        playerA.gameboard.clearGrid();\n        playerB.gameboard.clearGrid();\n        resetFleet();\n        gameStart();\n    }\n}\n\nconst battleship=()=>{\n\n    body\n    gameStart();\n    \n}\n\n\n\n;// ./src/index.js\n\n\n\n\nbattleship();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQSxLQUFLO0FBQ0w7Ozs7QUM3UitEOztBQUUvRDtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU0sU0FBUztBQUNmO0FBQ0EsSUFBSTs7QUFFSjs7OztBQzlCd0M7QUFDRTtBQUNEOztBQUV6QztBQUM4QztBQUNZO0FBQ1o7QUFDRTs7O0FBR2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQSwrQkFBK0IsT0FBTzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFVBQVU7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTs7Ozs7QUMzRDRDO0FBQ3RCOzs7QUFHdEIsVUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL2xvZ2ljL1NoaXAuanM/NGI2NyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9sb2dpYy9HYW1lYm9hcmQuanM/MmMwYSIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9sb2dpYy9QbGF5ZXIuanM/NmNlZiIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9kb20vbWFpbkNvbnRhaW5lci5qcz80MzkxIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL2RvbS9ncmlkLmpzPzg2MTAiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvZG9tL2ZsZWV0U2VsZWN0LmpzPzBiNTciLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvZG9tL3NldEZsZWV0LmpzP2IwZDgiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvZG9tL25leHRzdGFnZUJ0bi5qcz83Y2I1Iiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL2ZsZWV0U2V0dXAuanM/MzA2MiIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9kb20vcHJlSW5pdC5qcz83MTU1Iiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3N0YWdlcy9tZW51U3RhZ2UuanM/NmQ5NiIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9zdGFnZXMvZmxlZXRTZXR1cFN0YWdlLmpzPzAzMzciLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvZG9tL0F0dGFjay5qcz8wNjUyIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3N0YWdlcy9iYXR0bGVTdGFnZS5qcz8yYThmIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3N0YWdlcy9lbmRHYW1lU3RhZ2UuanM/MjE5MyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9QbGF5LmpzPzQ5YmQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgU2hpcHtcbiAgICAjbGVuZ3RoID0gMDtcbiAgICAjZGFtYWdlID0gMDtcbiAgICAjcG9zaXRpb25zID1bXTtcbiAgICAjaXNTdW5rID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBuYW1lKXtcbiAgICAgICAgdGhpcy4jbGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgfVxuICAgIC8vZ2V0XG4gICAgZ2V0TGVuZ3RoID0gKCkgPT57XG4gICAgICAgIHJldHVybiB0aGlzLiNsZW5ndGg7XG4gICAgfTtcbiAgICBnZXREYW1hZ2UgPSAoKSA9PntcbiAgICAgICAgcmV0dXJuIHRoaXMuI2RhbWFnZTtcbiAgICB9O1xuICAgIGdldElzU3VuayA9ICgpID0+e1xuICAgICAgICByZXR1cm4gdGhpcy4jaXNTdW5rO1xuICAgIH07XG4gICAgZ2V0UG9zaXRpb25zKCl7XG4gICAgICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbnM7XG4gICAgfTtcbiAgICAvL3NldFxuICAgIHNldFBvc2l0aW9uKHBvcyl7XG4gICAgICAgIHRoaXMuI3Bvc2l0aW9ucy5wdXNoKHBvcyk7XG4gICAgICAgIFxuICAgIH07XG4gICAgcmVzZXRQb3NpdGlvbnMoKXtcbiAgICAgICAgdGhpcy4jcG9zaXRpb25zID0gW107XG4gICAgfVxuICAgIGhpdCA9IChbeSwgeF0sIGhpdCkgPT57XG4gICAgICAgIHRoaXMuI2RhbWFnZSA9IHRoaXMuI2RhbWFnZSArIGhpdDtcbiAgICAgICAgdGhpcy4jc2lua1NoaXAoKTtcbiAgICB9XG4gICAgI3NpbmtTaGlwID0gKCkgPT57XG4gICAgICAgIGlmKCF0aGlzLiNpc1N1bmsgJiYgdGhpcy4jZGFtYWdlID09PSB0aGlzLiNsZW5ndGgpIHRoaXMuI2lzU3VuayA9IHRydWU7XG5cbiAgICB9XG4gICAgcmVzYXRTaGlwKCl7XG4gICAgICAgIHRoaXMuI2xlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuI2RhbWFnZSA9IDA7XG4gICAgICAgIHRoaXMuI3Bvc2l0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLiNpc1N1bmsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJyc7XG4gICAgfVxuICAgIFxuXG59XG5cbmV4cG9ydHtcbiAgICBTaGlwXG59IiwiaW1wb3J0IHsgU2hpcCB9IGZyb20gXCIuL1NoaXAuanNcIjtcbmNsYXNzIEdhbWVib2FyZHtcbiAgICAvL2luaXQgZ3JpZCBcbiAgICBncmlkID0gW107XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmdyaWQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMCB9LCAoKSA9PiBBcnJheSgxMCkuZmlsbChudWxsKSk7XG4gICAgfVxuXG4gICAgcG9wdWxhdGVHcmlkKFt4LCB5XSwgc2hpcExlbmd0aCwgbmFtZSwgZGlyZWN0aW9uID0gXCJob3Jpem9udGFsXCIpe1xuICAgICAgICBcbiAgICAgICAgaWYgKHggPCAwIHx8IHkgPCAwIHx8IHggPj0gdGhpcy5ncmlkLmxlbmd0aCB8fCB5ID49IHRoaXMuZ3JpZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3RhcnRpbmcgcG9zaXRpb24gb3V0IG9mIGJvdW5kcyEnKTtcbiAgICAgICAgfSBcbiAgICAgICAgY29uc3Qgc2hpcCA9IG5ldyBTaGlwKHNoaXBMZW5ndGgsIG5hbWUpICAgICAgXG5cbiAgICAgICAgaWYoZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIil7XG4gICAgICAgICAgICBpZih4ICsgc2hpcExlbmd0aD4gdGhpcy5ncmlkLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdzaGlwIG91dCBvZiBib3VuZHMgaG9yaXpvbnRhbGx5Jyk7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2hpcExlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmdyaWRbeV1beCtpXSE9PSBudWxsKXRocm93IG5ldyBFcnJvcignUG9zaXRpb24gb2NjdXBpZWQnKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwO2kgPHNoaXBMZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkW3ldW3ggKyBpXT0gc2hpcDtcbiAgICAgICAgICAgICAgICBzaGlwLnNldFBvc2l0aW9uKFt5LCB4KyBpXSlcbiAgICAgICAgICAgIH0gIFxuXG4gICAgICAgIH1cbiAgICAgICAgaWYoZGlyZWN0aW9uID09PSBcInZlcnRpY2FsXCIpe1xuICAgICAgICAgICAgaWYoeSsgc2hpcExlbmd0aCA+IHRoaXMuZ3JpZC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCdzaGlwIG91dCBvZiBib3VuZHMgdmVydGljYWxseScpO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHNoaXBMZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5ncmlkW3krIGldW3hdIT09IG51bGwpIHRocm93IG5ldyBFcnJvcignUG9zaXRpb24gb2NjdXBpZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzaGlwTGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFt5K2ldW3hdPSBzaGlwO1xuICAgICAgICAgICAgICAgIHNoaXAuc2V0UG9zaXRpb24oW3kgKyBpLCB4XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICB9XG4gICAgY2xlYXJHcmlkKCl7XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLmdyaWQgIT09IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5ncmlkLmZvckVhY2gocm93ID0+e1xuICAgICAgICAgICAgICAgIHJvdy5mb3JFYWNoKGNvbD0+e1xuICAgICAgICAgICAgICAgICAgICBpZihjb2wgaW5zdGFuY2VvZiBTaGlwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbC5yZXNhdFNoaXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29sID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL2lmIGNvb3JkaW5hdGUgaXMgbnVsbCBtZWFuaW5nIG5vIHNoaXAsXG4gICAgLy8gLSBzZXQgY29vcmRpbmF0ZSB0byBmYWxzZSBpbmRpY2F0aW5nIHRoZSBjb29yZGluYXRlIGlzIG5vIGxvbmdlciBhbiBvcHRpb247XG4gICAgcmVjaWV2ZUF0dGFjayhbeCwgeV0pe1xuICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5ncmlkW3ldW3hdO1xuICAgICAgICBpZihjZWxsID09PSBudWxsKXtcbiAgICAgICAgICAgIHRoaXMuZ3JpZFt5XVt4XSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1lbHNlICBpZihjZWxsIGluc3RhbmNlb2YgU2hpcCl7XG4gICAgICAgICAgICBjZWxsLmhpdChbeSwgeF0sIDEpO1xuICAgICAgICAgICAgdGhpcy5ncmlkW3ldW3hdID0gXCJoaXRcIjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vcmV0dXJucyBmYWxzZSBpZiBhdGxlYXN0IG9uZSBzaGlwIGlzIHN0aWxsIGFmbG9hdCByZXR1cm5zIHRydWUgaWYgYWxsIHNoaXBzIGFyZSBzdW5rXG4gICAgYWxsU2hpcHNTdW5rKCl7XG4gICAgICAgIGxldCBhbGxTdW5rPSB0cnVlO1xuICAgICAgICB0aGlzLmdyaWQuZm9yRWFjaChyb3cgPT57XG4gICAgICAgICAgICByb3cuZm9yRWFjaChjZWxsPT57XG4gICAgICAgICAgICAgICAgaWYoY2VsbCBpbnN0YW5jZW9mIFNoaXAgJiYgIWNlbGwuZ2V0SXNTdW5rKCkpYWxsU3VuayA9IGZhbHNlIDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBhbGxTdW5rO1xuICAgIH1cbiAgICBnZXRHcmlkID0gKCkgPT57XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQ7XG4gICAgfVxufVxuZXhwb3J0e1xuICAgIEdhbWVib2FyZFxufSIsImltcG9ydCB7IEdhbWVib2FyZCB9IGZyb20gXCIuL0dhbWVib2FyZFwiXG5pbXBvcnQgeyBTaGlwIH0gZnJvbSBcIi4vU2hpcFwiO1xuXG5jbGFzcyBQbGF5ZXJ7XG4gICAgI2lzQWkgPWZhbHNlXG4gICAgY29uc3RydWN0b3IoZW5hYmxlQWkpe1xuICAgICAgICB0aGlzLmdhbWVib2FyZD0gbmV3IEdhbWVib2FyZCgpO1xuICAgICAgICB0aGlzLiNpc0FpPSBlbmFibGVBaVxuICAgIH1cbiAgICBpc0NvbXB1dGVyKCl7XG4gICAgICAgIGlmKHRoaXMuI2lzQWkpIHJldHVybiB0cnVlO1xuICAgICAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2VuRmxlZXQoKXtcbiAgICAgICAgaWYodGhpcy4jaXNBaSl7XG4gICAgICAgICAgICBjb25zdCBmbGVldCA9IFtcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdDYXJyaWVyJywgbGVuZ3RoOiA1IH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQmF0dGxlc2hpcCcsIGxlbmd0aDogNCB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0NydWlzZXInLCBsZW5ndGg6IDMgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdTdWJtYXJpbmUnLCBsZW5ndGg6IDMgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdEZXN0cm95ZXInLCBsZW5ndGg6IDIgfSwgXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgZmxlZXQuZm9yRWFjaChzaGlwID0+e1xuICAgICAgICAgICAgICAgIGxldCBwbGFjZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSghcGxhY2VkKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gTWF0aC5yYW5kb20oKSA+IDAuNSA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSogMTApO1xuICAgICAgICAgICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVib2FyZC5wb3B1bGF0ZUdyaWQoW3gsIHldLCBzaGlwLmxlbmd0aCwgc2hpcC5uYW1lLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9Y2F0Y2goZXJyb3Ipe1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuICAgIGFpQXR0YWNrKG9wcG9uZW50LCl7XG4gICAgICAgIGxldCB4LCB5O1xuICAgICAgICBkb3tcbiAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqIDEwKTtcbiAgICAgICAgICAgIHkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqIDEwKTtcbiAgICAgICAgfXdoaWxlKHRoaXMuI2lzQ2VsbFNob3RBdChvcHBvbmVudC5nYW1lYm9hcmQuZ2V0R3JpZCgpLCB4LCB5KSl7ICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBoaXRTdGF0dXMgPSBvcHBvbmVudC5nYW1lYm9hcmQucmVjaWV2ZUF0dGFjayhbeCwgeV0pO1xuXG4gICAgICAgICAgICByZXR1cm4ge2hpdDogaGl0U3RhdHVzLCB4ICwgeX07XG5cbiAgICAgICAgfVxuICAgIH1cbiAgICAjaXNDZWxsU2hvdEF0KGJvYXJkLCB4LCB5KXtcbiAgICAgICAgY29uc3QgY2VsbCA9IGJvYXJkW3ldW3hdO1xuICAgICAgICByZXR1cm4gY2VsbCA9PT0gZmFsc2UgfHwgY2VsbCA9PT0gXCJoaXRcIiA7XG4gICAgfVxuICAgIC8vYXR0ZW1wdCBhdCBhIHNtYXJ0ZXIgYWkgKG5vdCByZXF1aXJlZCBmb3IgdGhlIHByb2plY3QpXG4gICAgI2h1bnRTaGlwKHgsIHksIG9wcG9uZW50KXtcbiAgICAgICAgY29uc3QgbmVhckJ5Q2VsbHMgPSBbXG4gICAgICAgICAgICBbeCwgeSAtMV0sXG4gICAgICAgICAgICBbeCwgeSArIDFdLFxuICAgICAgICAgICAgW3ggLTEgLCB5XSxcbiAgICAgICAgICAgIFt4ICsgMSwgeV1cbiAgICAgICAgXVxuICAgICAgICBsZXQgdmFsaWRDZWxscyA9IFtdO1xuICAgICAgICBuZWFyQnlDZWxscy5mb3JFYWNoKGNlbGw9PntcbiAgICAgICAgICAgIGNvbnN0IFtuZXdYLG5ld1ldID0gY2VsbDtcbiAgICAgICAgICAgIGlmIChuZXdYID49IDAgJiYgbmV3WCA8IDEwICYmIG5ld1kgPj0gMCAmJiBuZXdZIDwgMTApIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY2VsbCBpcyBlaXRoZXIgYSBtaXNzIChmYWxzZSkgb3IgXCJoaXRcIiAoYWxyZWFkeSBhdHRhY2tlZClcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsU3RhdHVzID0gb3Bwb25lbnQuZ2FtZWJvYXJkLmdldEdyaWQoKVtuZXdZXVtuZXdYXTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbFN0YXR1cyAhPT0gZmFsc2UgJiYgY2VsbFN0YXR1cyAhPT0gXCJoaXRcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZENlbGxzLnB1c2goW25ld1gsIG5ld1ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGlmICh2YWxpZENlbGxzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB2YWxpZENlbGxzLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBbdGFyZ2V0WCwgdGFyZ2V0WV0gPSB2YWxpZENlbGxzW3JhbmRvbUluZGV4XTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCBgdmFsaWQgbmV4dCBtb3ZlczogJHt2YWxpZENlbGxzfWApO1xuICAgICAgICAgICAgcmV0dXJue3RhcmdldFgsIHRhcmdldFl9O1xuICAgXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB9XG59XG5cbmV4cG9ydHtcbiAgICBQbGF5ZXJcbn0iLCJpbXBvcnQgXCIuLi8uLi9zdHlsZXMuY3NzXCI7XG5jb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcblxuLy9tYWluY29udGFpbmVyXG5jb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdtYWluLWNvbnRhaW5lcicpO1xuY29udGFpbmVyLnN0eWxlLmdyaWRBcmVhID0gJ21haW4nO1xuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnZ3JpZCc7XG5cbmNvbnRhaW5lci5zdHlsZS5nYXAgPSBcIjJweFwiO1xuLy9jb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjZGRkZGRkZmZcIjtcblxuLy9nYW1ldGl0bGVcbmNvbnN0IHBsYXllclRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGV2Jyk7XG5wbGF5ZXJUaXRsZS5zdHlsZS5ncmlkQXJlYSA9ICd0aXRsZSc7XG5wbGF5ZXJUaXRsZS5pbm5lckhUTUwgPSAnQmF0dGxlc2hpcC4nO1xucGxheWVyVGl0bGUuc3R5bGUuZm9udFNpemUgPSBcIjY0cHhcIjtcbnBsYXllclRpdGxlLnN0eWxlLmFsaWduU2VsZiA9IFwiY2VudGVyXCI7XG5wbGF5ZXJUaXRsZS5zdHlsZS5qdXN0aWZ5U2VsZiA9IFwiY2VudGVyXCI7XG5cbmJvZHkuc3R5bGUuZ3JpZFRlbXBsYXRlQXJlYXM9IGBcbicuIHRpdGxlIC4nXG4nbWFpbiBtYWluIG1haW4nXG4nLiAuIC4nIGA7XG5ib2R5LmFwcGVuZENoaWxkKHBsYXllclRpdGxlKTtcbmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuXG4gZXhwb3J0e1xuICAgIGJvZHksXG4gICAgY29udGFpbmVyLFxuXG4gfSIsIlxuY29uc3QgY3JlYXRlQm9hcmQgPShib2FyZElkKT0+e1xuICAgIGNvbnN0IGdyaWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBncmlkLnN0eWxlLndpZHRoID0gXCI1MDBweFwiO1xuICAgIGdyaWQuc3R5bGUuaGVpZ2h0ID0gXCI1MDBweFwiXG5cbiAgICBncmlkLnN0eWxlLmRpc3BsYXkgPSBcImdyaWRcIjtcbiAgICBncmlkLmlkID1ib2FyZElkO1xuICAgIGdyaWQuc3R5bGUuZ2FwID0gXCIycHhcIjtcbiAgICBncmlkLnN0eWxlLnBhZGRpbmcgPSBcIjJweFwiXG4gICAgZ3JpZC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IFwiI2IxY2FjOWZmXCI7XG4gICAgZ3JpZC5zdHlsZS5ncmlkVGVtcGxhdGVDb2x1bW5zID0gJ3JlcGVhdCgxMCwgMWZyKSc7XG4gICAgZ3JpZC5zdHlsZS5ncmlkVGVtcGxhdGVSb3dzID0gJ3JlcGVhdCgxMCwgMWZyKSc7XG4gICAgY29uc3QgY2VsbHMgPSBbXTtcbiAgICBmb3IobGV0IHggPSAwOyB4IDwxMCA7IHgrKyl7XG4gICAgICAgIGZvcihsZXQgeSA9IDA7IHkgPCAxMDsgeSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGNlbGwuc2V0QXR0cmlidXRlKFwiaWRcIixgJHt5fSwke3h9YCk7ICBcbiAgICAgICAgICAgIGNlbGwudGV4dENvbnRlbnQgPSBcIiAgXCI7XG4gICAgICAgICAgICBjZWxsLmNsYXNzTGlzdC5hZGQoJ2NlbGwnKTtcbiAgICAgICAgICAgIGNlbGwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztcblxuICAgICAgICAgICAgY2VsbC5kYXRhc2V0LnggPSB4O1xuICAgICAgICAgICAgY2VsbC5kYXRhc2V0LnkgPSB5O1xuICAgICAgICAgICAgY2VsbHMucHVzaChjZWxsKTtcbiAgICAgICAgICAgIGdyaWQuYXBwZW5kQ2hpbGQoY2VsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtncmlkLCBjZWxsc307XG59XG5cbmV4cG9ydHtcbiAgICBjcmVhdGVCb2FyZCxcbn0iLCJcbi8vbmFtZTogJ0NhcnJpZXInLCBsZW5ndGg6IDUgXG4vL25hbWU6ICdCYXR0bGVzaGlwJywgbGVuZ3RoOiA0IFxuLy9uYW1lOiAnQ3J1aXNlcicsIGxlbmd0aDogMyBcbi8vbmFtZTogJ1N1Ym1hcmluZScsIGxlbmd0aDogMyBcbi8vbmFtZTogJ0Rlc3Ryb3llcicsIGxlbmd0aDogMiBcbmxldCBzZWxlY3RlZFNoaXAgPSBudWxsO1xubGV0IG9yaWVudGF0aW9uID0gXCJob3Jpem9udGFsXCI7XG5jb25zdCBjYXJyaWVyID1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuY2Fycmllci5pbm5lckhUTUw9J0NhcnJpZXInO1xuY2Fycmllci5pZCA9ICdDYXJyaWVyJztcbmNhcnJpZXIuY2xhc3NOYW1lID0gXCJpbi1idXR0b25cIjtcbmNhcnJpZXIuY2xhc3NMaXN0LmFkZCgnc2hpcC1idG4nKTtcbmNhcnJpZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCgpPT57XG4gICAgc2VsZWN0ZWRTaGlwID0gY2Fycmllci5pZDtcbiAgICBjb25zb2xlLmxvZyhgc2VsZWN0ZWQgc2hpcCBzZXQgdG86JHtzZWxlY3RlZFNoaXB9IGApXG59KVxuXG5cbmNvbnN0IGJhdHRsZVNoaXAgPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5iYXR0bGVTaGlwLmlubmVySFRNTD0nQmF0dGxlc2hpcCc7XG5iYXR0bGVTaGlwLmlkID0gJ0JhdHRsZXNoaXAnO1xuYmF0dGxlU2hpcC5jbGFzc05hbWUgPSBcImluLWJ1dHRvblwiO1xuYmF0dGxlU2hpcC5jbGFzc0xpc3QuYWRkKCdzaGlwLWJ0bicpO1xuYmF0dGxlU2hpcC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsKCk9PntcbiAgICBzZWxlY3RlZFNoaXAgPSBiYXR0bGVTaGlwLmlkO1xuICAgIGNvbnNvbGUubG9nKGBzZWxlY3RlZCBzaGlwIHNldCB0bzoke3NlbGVjdGVkU2hpcH0gYClcbn0pXG5cbmNvbnN0IGNydWlzZXIgPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5jcnVpc2VyLmlubmVySFRNTD0nQ3J1aXNlcic7XG5jcnVpc2VyLmlkID0gJ0NydWlzZXInO1xuY3J1aXNlci5jbGFzc05hbWUgPSBcImluLWJ1dHRvblwiO1xuY3J1aXNlci5jbGFzc0xpc3QuYWRkKCdzaGlwLWJ0bicpO1xuY3J1aXNlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsKCk9PntcbiAgICBzZWxlY3RlZFNoaXAgPSBjcnVpc2VyLmlkO1xuICAgIGNvbnNvbGUubG9nKGBzZWxlY3RlZCBzaGlwIHNldCB0bzoke3NlbGVjdGVkU2hpcH0gYClcbn0pXG5cbmNvbnN0IHN1Ym1hcmluZSA9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbnN1Ym1hcmluZS5pbm5lckhUTUw9J1N1Ym1hcmluZSc7XG5zdWJtYXJpbmUuaWQgPSAnU3VibWFyaW5lJztcbnN1Ym1hcmluZS5jbGFzc05hbWUgPSBcImluLWJ1dHRvblwiO1xuc3VibWFyaW5lLmNsYXNzTGlzdC5hZGQoJ3NoaXAtYnRuJyk7XG5zdWJtYXJpbmUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCgpPT57XG4gICAgc2VsZWN0ZWRTaGlwID0gc3VibWFyaW5lLmlkO1xuICAgIGNvbnNvbGUubG9nKGBzZWxlY3RlZCBzaGlwIHNldCB0bzoke3NlbGVjdGVkU2hpcH0gYClcbn0pXG5cbmNvbnN0IGRlc3Ryb3llciA9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbmRlc3Ryb3llci5pbm5lckhUTUw9J0Rlc3Ryb3llcic7XG5kZXN0cm95ZXIuaWQgPSAnRGVzdHJveWVyJztcbmRlc3Ryb3llci5jbGFzc05hbWUgPSBcImluLWJ1dHRvblwiO1xuZGVzdHJveWVyLmNsYXNzTGlzdC5hZGQoJ3NoaXAtYnRuJyk7XG5kZXN0cm95ZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCgpPT57XG4gICAgc2VsZWN0ZWRTaGlwID0gZGVzdHJveWVyLmlkO1xuICAgIGNvbnNvbGUubG9nKGBzZWxlY3RlZCBzaGlwIHNldCB0bzoke3NlbGVjdGVkU2hpcH0gYCkgICAgXG59KVxuY29uc3QgZGlyZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbmRpcmVjdGlvbi5jbGFzc05hbWUgPSBcImluLWJ1dHRvblwiO1xuZGlyZWN0aW9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiI2ZmODM4M2ZmXCI7XG5kaXJlY3Rpb24uaW5uZXJIVE1MID0gb3JpZW50YXRpb247XG5kaXJlY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsKCk9PntcbiAgICBpZihvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpe1xuICAgICAgICBvcmllbnRhdGlvbiA9IFwidmVydGljYWxcIjsgICBcbiAgICAgICAgZGlyZWN0aW9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiIzk5ZWM4ZmZmXCI7IFxuICAgIH1lbHNle1xuICAgICAgICBvcmllbnRhdGlvbiA9IFwiaG9yaXpvbnRhbFwiO1xuICAgICAgICBkaXJlY3Rpb24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjZmY4MzgzZmZcIjtcbiAgICB9XG4gICAgZGlyZWN0aW9uLmlubmVySFRNTCA9IG9yaWVudGF0aW9uXG59KVxuXG5cbmV4cG9ydCB7XG4gICAgY2FycmllcixcbiAgICBiYXR0bGVTaGlwLFxuICAgIGNydWlzZXIsXG4gICAgc3VibWFyaW5lLFxuICAgIGRlc3Ryb3llcixcbiAgICBzZWxlY3RlZFNoaXAsXG4gICAgZGlyZWN0aW9uLFxuICAgIG9yaWVudGF0aW9uXG59IiwiaW1wb3J0ICcuLi8uLi9zdHlsZXMuY3NzJztcbmltcG9ydCB7IGNyZWF0ZUJvYXJkIH0gZnJvbSBcIi4vZ3JpZFwiO1xuaW1wb3J0IHsgY2FycmllciwgYmF0dGxlU2hpcCwgY3J1aXNlciwgc3VibWFyaW5lLCBkZXN0cm95ZXIsIGRpcmVjdGlvbiB9IGZyb20gXCIuL2ZsZWV0U2VsZWN0XCI7XG5cbmNvbnN0IHZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbnZpZXcuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xudmlldy5jbGFzc0xpc3QuYWRkKCdmbGVldC12aWV3JylcblxuY29uc3QgZmxlZXRDb250ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5mbGVldENvbnQuY2xhc3NMaXN0LmFkZCgnc2hpcC1CdG5zJyk7XG5mbGVldENvbnQuc3R5bGUuZ3JpZEFyZWEgPSAnY2hvaWNlcyc7XG5mbGVldENvbnQuc3R5bGUuYWxpZ25Db250ZW50ID0gXCJjZW50ZXJcIjtcbmZsZWV0Q29udC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiY2VudGVyXCI7XG5cbnZpZXcuc3R5bGUuYWxpZ25TZWxmID0gXCJjZW50ZXJcIjtcbnZpZXcuc3R5bGUuanVzdGlmeVNlbGYgPSBcImNlbnRlclwiO1xudmlldy5zdHlsZS5qdXN0aWZ5SXRlbXMgPSAnY2VudGVyJztcbnZpZXcuc3R5bGUuYWxpZ25JdGVtcyA9ICdjZW50ZXInO1xuXG52aWV3LnN0eWxlLmRpc3BsYXkgPSBcImdyaWRcIjtcbnZpZXcuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xudmlldy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbnZpZXcuc3R5bGUuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IFwiMWZyIDJmciAxZnJcIjtcbnZpZXcuc3R5bGUuZ3JpZFRlbXBsYXRlUm93cyA9IFwiMWZyIDRmciAxZnJcIjtcblxudmlldy5zdHlsZS5ncmlkVGVtcGxhdGVBcmVhcyA9IGBcblwiLiB0aXRsZSAuXCJcblwiY2hvaWNlcyBncmlkQSAuXCJcblwiLiBuZXh0ICAuXCJgXG5cbmNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG50aXRsZS5zdHlsZS5ncmlkQXJlYSA9IFwidGl0bGVcIjtcbnRpdGxlLmlubmVySFRNTCA9IFwicG9zaXRpb24geW91ciBmbGVldFwiO1xudGl0bGUuc3R5bGUuYWxpZ25TZWxmID0gXCJjZW50ZXJcIjtcbnRpdGxlLnN0eWxlLmp1c3RpZnlTZWxmID0gXCJjZW50ZXJcIjtcbmNvbnN0IHtncmlkLCBjZWxsc30gPSBjcmVhdGVCb2FyZCgncGxheWVyQScpO1xuZ3JpZC5zdHlsZS5ncmlkQXJlYT0gXCJncmlkQVwiO1xuXG5cbnZpZXcuYXBwZW5kQ2hpbGQoZmxlZXRDb250KTtcbnZpZXcuYXBwZW5kQ2hpbGQoZ3JpZCk7XG52aWV3LmFwcGVuZENoaWxkKHRpdGxlKTtcblxuXG5mbGVldENvbnQuYXBwZW5kQ2hpbGQoY2Fycmllcik7XG5mbGVldENvbnQuYXBwZW5kQ2hpbGQoYmF0dGxlU2hpcCk7XG5mbGVldENvbnQuYXBwZW5kQ2hpbGQoY3J1aXNlcik7XG5mbGVldENvbnQuYXBwZW5kQ2hpbGQoc3VibWFyaW5lKTtcbmZsZWV0Q29udC5hcHBlbmRDaGlsZChkZXN0cm95ZXIpO1xuZmxlZXRDb250LmFwcGVuZENoaWxkKGRpcmVjdGlvbik7XG5cbmV4cG9ydCB7XG4gICAgdmlldyxcbiAgICBncmlkXG59IiwiXG5jb25zdCBjcmVhdGVOZXh0QnRuPShsYWJlbCwgcGFyZW50KT0+e1xuICAgIGNvbnN0IGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJ0bi5pbm5lckhUTUwgPSBsYWJlbDtcbiAgICBidG4uc3R5bGUuZ3JpZEFyZWE9IFwibmV4dFwiO1xuICAgIGJ0bi5jbGFzc05hbWUgPSBcImluLWJ1dHRvblwiO1xuICAgIGJ0bi5pZCA9IFwibmV4dFwiOyBcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoYnRuKTtcbiAgICByZXR1cm4gYnRuICBcbn1cblxuZXhwb3J0IHtcbiAgICBjcmVhdGVOZXh0QnRuLFxufSIsImltcG9ydCB7IHZpZXcgYXMgZmxlZXRTZXRWaWV3IH0gZnJvbSBcIi4vZG9tL3NldEZsZWV0XCI7XG5pbXBvcnQgeyBzZWxlY3RlZFNoaXAsIG9yaWVudGF0aW9ufSBmcm9tIFwiLi9kb20vZmxlZXRTZWxlY3RcIjtcbmltcG9ydCB7IGNyZWF0ZU5leHRCdG4gfSBmcm9tIFwiLi9kb20vbmV4dHN0YWdlQnRuXCI7XG4vL2ltcG9ydCBncmlkc1xuaW1wb3J0IHsgU2hpcCB9IGZyb20gXCIuL2xvZ2ljL1NoaXBcIjtcbmltcG9ydCB7IGdyaWQgYXMgc2V0dGluZ0dyaWQgfSBmcm9tICcuL2RvbS9zZXRGbGVldCc7XG5cbi8vcHJvZ3Jlc3MgYnV0dG9uXG5jb25zdCBuZXh0ID1jcmVhdGVOZXh0QnRuKCduZXh0c3RhZ2UnLCBmbGVldFNldFZpZXcpO1xubmV4dC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4vL2dyaWQgdWkgaGFuZGxlcnNcbmNvbnN0IHN5bmNHcmlkID0gKHBsYXllckdyaWQgKT0+e1xuICAgIGdyaWRTeW5jUmVzdGVyKClcblxuICAgIHBsYXllckdyaWQuZm9yRWFjaCgobG9naWNSb3csIHlJbmRleCkgPT57XG4gICAgICAgIGxvZ2ljUm93LmZvckVhY2goKGxvZ2ljQ2VsbCwgeEluZGV4KSA9PntcbiAgICAgICAgICAgIGlmKGxvZ2ljQ2VsbCBpbnN0YW5jZW9mIFNoaXApe1xuICAgICAgICAgICAgICAgIC8vZ2V0IGRvbSBjZWxsc1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2ljQ2VsbElkID0gYCR7eEluZGV4fSwke3lJbmRleH1gICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxzID0gc2V0dGluZ0dyaWQucXVlcnlTZWxlY3RvckFsbCgnLmNlbGwnKTtcblxuICAgICAgICAgICAgICAgIC8vY2hlY2sgc2hpcCBwbGFjZW1lbnQgaW4gdGhlIGdhbWVib2FyZCAyRGFycmF5XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2VsbHMuZm9yRWFjaChjZWxsPT57XG4gICAgICAgICAgICAgICAgICAgIGlmKGNlbGwuaWQgPT09IGxvZ2ljQ2VsbElkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coY2VsbC5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiIzZjZjFlNmZmXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0pXG4gICAgfSlcblxufVxuY29uc3QgZ3JpZFN5bmNSZXN0ZXIgPSAoKT0+e1xuICAgIGNvbnN0IGNlbGxzID0gc2V0dGluZ0dyaWQucXVlcnlTZWxlY3RvckFsbCgnLmNlbGwnKTtcbiAgICBjZWxscy5mb3JFYWNoKGNlbGw9PntcbiAgICAgICAgY2VsbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiNmZmZmZmZmZlwiO1xuICAgIH0pXG59XG5cbi8vY2VsbCBsaXN0ZW5lcnNcbmNvbnN0IGFkZEV2ZW50TGlzdGVuZXJUb2NlbGxzID0gKHBsYXllcik9PntcblxuICAgIGNvbnN0IGNlbGxzID0gc2V0dGluZ0dyaWQucXVlcnlTZWxlY3RvckFsbCgnLmNlbGwnKTtcblxuICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PntcbiAgICAgICAgY2VsbC5hZGRFdmVudExpc3RlbmVyKGBjbGlja2AsKGUpPT57XG4gICAgICAgICAgICBjb25zdCBjbGlja2VkSWQgPSBlLnRhcmdldC5pZDtcbiAgICAgICAgICAgIGhhbmRsZUNlbGxDbGljayhjbGlja2VkSWQsIHBsYXllcik7XG4gICAgICAgIH0pXG4gICAgICAgIGNlbGwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywoZSk9PntcbiAgICAgICAgICAgIGNvbnN0W3JvdywgY29sXT0gZS50YXJnZXQuaWQuc3BsaXQoJywnKS5tYXAoTnVtYmVyKVxuICAgICAgICAgICAgOyAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoc2VsZWN0ZWRTaGlwICYmICFtb3ZpbmdzaGlwKXtcbiAgICAgICAgICAgICAgICBjb25zdCBzaGlwID0gZ2V0U2hpcEJ5TmFtZShzZWxlY3RlZFNoaXApO1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodFByZXZpZXcocGxheWVyLCByb3csIGNvbCwgc2hpcC5sZW5ndGgsIG9yaWVudGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG1vdmluZ3NoaXApe1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodFByZXZpZXcocGxheWVyLCByb3csIGNvbCwgbW92aW5nc2hpcC5nZXRMZW5ndGgoKSwgb3JpZW50YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBjZWxsLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCgpPT57XG4gICAgICAgICAgICByZXNldFByZXZpZXcoKTtcbiAgICAgICAgfSlcbiAgICB9KVxufVxubGV0IHBsYWNlZFNoaXBzID0gW107XG5sZXQgbW92aW5nc2hpcCA9IG51bGw7XG4vL2hhbmRsZXMgY2xpY2tcbmNvbnN0IGhhbmRsZUNlbGxDbGljayA9IChpZCwgcGxheWVyKT0+e1xuICAgIGNvbnN0W3JvdywgY29sXSA9IGlkLnNwbGl0KCcsJykubWFwKE51bWJlcik7XG4gICAgY29uc3QgZ3JpZCA9IHBsYXllci5nYW1lYm9hcmQuZ2V0R3JpZCgpO1xuICAgIGNvbnN0IGNlbGxEYXRhID1ncmlkW2NvbF1bcm93XTtcblxuICAgIC8vbm8gc2hpcCBzZWxlY3RlZCwgbm8gc2hpcCBtb3ZpbmcgY3VycmVudGx5XG4gICAgaWYoIXNlbGVjdGVkU2hpcCAmJiAhbW92aW5nc2hpcCkgcmV0dXJuO1xuXG4gICAgLy9oYW5kZWxzIHNoaXAgc2VsZWN0aW9uIGZvciBtb3ZlbWVudFxuICAgIGlmKGNlbGxEYXRhIGluc3RhbmNlb2YgU2hpcCAmJiAhbW92aW5nc2hpcCl7XG4gICAgICAgIG1vdmluZ3NoaXAgPSBjZWxsRGF0YTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhgc2VsZWN0ZWQgc2hpcCB0byBtb3ZlOiAke21vdmluZ3NoaXAubmFtZX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvL2hhbmRlbHMgYW4gYWxyZWFkeSBtb3Zpbmcgc2hpcFxuICAgIGlmKG1vdmluZ3NoaXApe1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNoaXBNb3ZlSGFuZGxlcihwbGF5ZXIsIG1vdmluZ3NoaXAsIHJvdywgY29sLCBvcmllbnRhdGlvbik7XG4gICAgICAgICAgICBtb3ZpbmdzaGlwID0gbnVsbDtcbiAgICAgICAgICAgIHN5bmNHcmlkKGdyaWQpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYHNoaXAgbW92ZWQgc3VjY2Vzc2Z1bGx5LmApO1xuICAgIFxuICAgICAgICB9Y2F0Y2h7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDYW5ub3QgbW92ZSBzaGlwIGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vcHJldmVudHMgZHVwbGljYXRlc1xuICAgIGlmKHBsYWNlZFNoaXBzLmluY2x1ZGVzKHNlbGVjdGVkU2hpcCkpe1xuICAgICAgICBjb25zb2xlLmxvZyhgU2hpcCBcIiR7c2VsZWN0ZWRTaGlwfVwiIGFscmVhZHkgcGxhY2VkLmApO1xuICAgICAgICByZXR1cm47XG4gICAgfWVsc2V7XG4gICAgICAgIGNvbnN0IHNoaXAgPSBnZXRTaGlwQnlOYW1lKHNlbGVjdGVkU2hpcCk7XG4gICAgICAgIHBsYXllci5nYW1lYm9hcmQucG9wdWxhdGVHcmlkKFtyb3csY29sXSwgc2hpcC5sZW5ndGgsIHNlbGVjdGVkU2hpcCwgb3JpZW50YXRpb24pO1xuICAgICAgICBwbGFjZWRTaGlwcy5wdXNoKHNlbGVjdGVkU2hpcCk7XG4gICAgICAgIHN5bmNHcmlkKGdyaWQpO1xuXG4gICAgICAgIC8vZGlzYWJsZSB0aGUgc2hpcCBidG4gaW4gdWlcbiAgICAgICAgY29uc3Qgc2hpcERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGVjdGVkU2hpcCk7XG4gICAgICAgIHNoaXBEaXYuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgc2hpcERpdi5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7ICBcbiAgICB9XG4gICAgLy9jaGVjayBpZiBhbGwgc2hpcHMgYXJlIHBsYWNlZFxuICAgIGlmKHBsYWNlZFNoaXBzLmxlbmd0aCA9PT0gNSl7XG4gICAgICAgIG5leHQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICB9XG59XG5jb25zdCBnZXRTaGlwQnlOYW1lID0gKHNoaXBOYW1lKT0+e1xuICAgIGNvbnN0IGZsZWV0ID0gW1xuICAgICAgICB7IG5hbWU6ICdDYXJyaWVyJywgbGVuZ3RoOiA1IH0sXG4gICAgICAgIHsgbmFtZTogJ0JhdHRsZXNoaXAnLCBsZW5ndGg6IDQgfSxcbiAgICAgICAgeyBuYW1lOiAnQ3J1aXNlcicsIGxlbmd0aDogMyB9LFxuICAgICAgICB7IG5hbWU6ICdTdWJtYXJpbmUnLCBsZW5ndGg6IDMgfSxcbiAgICAgICAgeyBuYW1lOiAnRGVzdHJveWVyJywgbGVuZ3RoOiAyIH0sIFxuICAgIF07XG4gICAgcmV0dXJuIGZsZWV0LmZpbmQoc2hpcD0+c2hpcC5uYW1lID09PSBzaGlwTmFtZSk7XG59XG5jb25zdCBzaGlwTW92ZUhhbmRsZXI9KHBsYXllciwgc2hpcCwgbmV3U3RhcnRYLCBuZXdTdGFydFksIGRpcmVjdGlvbik9PntcbiAgICAgICAgc2hpcC5nZXRQb3NpdGlvbnMoKS5mb3JFYWNoKChbeSwgeF0pPT57XG4gICAgICAgICAgICBwbGF5ZXIuZ2FtZWJvYXJkLmdyaWRbeV1beF09IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBzaGlwLnJlc2V0UG9zaXRpb25zKCk7XG4gICAgICAgIHBsYXllci5nYW1lYm9hcmQucG9wdWxhdGVHcmlkKFtuZXdTdGFydFgsbmV3U3RhcnRZXSwgc2hpcC5nZXRMZW5ndGgoKSwgc2hpcC5uYW1lLCBkaXJlY3Rpb24pO1xuICAgICAgICBzeW5jR3JpZChwbGF5ZXIuZ2FtZWJvYXJkLmdldEdyaWQoKSk7XG5cbiAgICB9XG4vL2hhbmRlbHMgcHJpZXZpZXdcbmNvbnN0IGhpZ2hsaWdodFByZXZpZXcgPSAocGxheWVyLCBzdGFydFIsIHN0YXJ0QywgbGVuZ3RoLCBkaXJlY3Rpb24pPT57XG4gICAgcmVzZXRQcmV2aWV3KCk7XG4gICAgY29uc3QgY2VsbHMgPSBzZXR0aW5nR3JpZC5xdWVyeVNlbGVjdG9yQWxsKCcuY2VsbCcpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJvdyA9IHN0YXJ0UjtcbiAgICAgICAgbGV0IGNvbCA9IHN0YXJ0QztcblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHJvdyArPSBpO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAndmVydGljYWwnKSBjb2wgKz0gaTtcblxuICAgICAgICBjb25zdCBjZWxsID0gQXJyYXkuZnJvbShjZWxscykuZmluZChjID0+IGMuaWQgPT09IGAke3Jvd30sJHtjb2x9YCk7XG4gICAgICAgIGlmIChjZWxsKSB7XG4gICAgICAgICAgICBjZWxsLmRhdGFzZXQucHJldmlldyA9ICd0cnVlJztcbiAgICAgICAgICAgIGNlbGwuc3R5bGUub3V0bGluZSA9ICcycHggc29saWQgIzAwYmZmZic7IFxuICAgICAgICAgICAgY2VsbC5zdHlsZS5zaGFkb3dCb3ggPSBcIjBweCAwcHggNDBweCAtMTBweCAjMDBiZmZmXCJcbiAgICAgICAgICAgIGNlbGwuc3R5bGUub3V0bGluZU9mZnNldCA9ICctMnB4JztcbiAgICAgICAgfVxuICAgIH1cblxufVxuY29uc3QgcmVzZXRQcmV2aWV3PSgpPT57XG4gICAgY29uc3QgY2VsbHMgPSBzZXR0aW5nR3JpZC5xdWVyeVNlbGVjdG9yQWxsKCcuY2VsbCcpO1xuXG4gICAgY2VsbHMuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgaWYgKGNlbGwuZGF0YXNldC5wcmV2aWV3KSB7XG4gICAgICAgICAgICBjZWxsLnN0eWxlLnNoYWRvd0JveCA9ICdub25lJ1xuICAgICAgICAgICAgY2VsbC5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xuICAgICAgICAgICAgZGVsZXRlIGNlbGwuZGF0YXNldC5wcmV2aWV3O1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCByZXNldEZsZWV0ID0gKCk9PntcbiAgICBwbGFjZWRTaGlwcyA9IFtdO1xuICAgIG1vdmluZ3NoaXAgPSBudWxsO1xuICAgIGdyaWRTeW5jUmVzdGVyKCk7XG4gICAgY29uc3Qgc2hpcEJ1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuc2hpcC1idG4nKTtcbiAgICBzaGlwQnV0dG9ucy5mb3JFYWNoKGJ1dHRvbiA9PntcbiAgICAgICAgYnV0dG9uLnBvaW50ZXJFdmVudHMgPSAnYXV0byc7XG4gICAgICAgIGJ1dHRvbi5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuICAgIH0pXG4gICAgaWYoZmxlZXRTZXRWaWV3LmNvbnRhaW5zKG5leHQpKXtcbiAgICAgICAgbmV4dC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbn1cblxuZXhwb3J0e1xuICAgIGFkZEV2ZW50TGlzdGVuZXJUb2NlbGxzLFxuICAgIHJlc2V0RmxlZXQsXG4gICAgbmV4dFxufSIsImxldCBnYW1lTW9kZSA9IG51bGw7XG5jb25zdCB2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG52aWV3LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbnZpZXcuc3R5bGUuYWxpZ25TZWxmID0gXCJjZW50ZXJcIjtcbnZpZXcuc3R5bGUuanVzdGlmeVNlbGYgPSBcImNlbnRlclwiO1xudmlldy5zdHlsZS5kaXNwbGF5ID0gXCJncmlkXCI7XG52aWV3LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbnZpZXcuc3R5bGUud2lkdGggPSAnMTAwJSc7XG52aWV3LnN0eWxlLmdyaWRUZW1wbGF0ZUNvbHVtbnMgPSBcInJlcGVhdCg0ICwgMWZyKVwiO1xudmlldy5zdHlsZS5ncmlkVGVtcGxhdGVSb3dzID0gXCIxZnIgMWZyXCI7XG5cbnZpZXcuc3R5bGUuZ3JpZFRlbXBsYXRlQXJlYXMgPSBgXG5cIi4gdGl0bGUgdGl0bGUgLlwiXG5cIi4gcHZwIHB2bnBjIC5cImBcblxuY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbnRpdGxlLmlubmVySFRNTCA9IFwiY2hvb3NlIGdhbWUgbW9kZVwiO1xudGl0bGUuc3R5bGUuZ3JpZEFyZWEgPSBcInRpdGxlXCI7XG50aXRsZS5zdHlsZS5hbGlnblNlbGYgPSBcImNlbnRlclwiO1xudGl0bGUuc3R5bGUuanVzdGlmeVNlbGY9XCJjZW50ZXJcIjtcblxuY29uc3QgcHZwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5wdnAuaW5uZXJIVE1MID0gXCJQbGF5ZXIgdnMuIFBsYXllclwiO1xucHZwLmlkID0gJ3B2cCc7XG5wdnAuc3R5bGUuZ3JpZEFyZWE9IFwicHZwXCI7XG5wdnAuc3R5bGUuanVzdGlmeVNlbGYgPSBcImNlbnRlclwiO1xucHZwLmNsYXNzTmFtZSA9IFwiaW4tYnV0dG9uXCI7XG5wdnAuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbnB2cC5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG5cbmNvbnN0IHB2bnBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5wdm5wYy5pbm5lckhUTUwgPSBcIlBsYXllciB2cy4gQ29tcHV0ZXJcIjtcbnB2bnBjLmlkID0gJ3B2bnBjJztcbnB2bnBjLnN0eWxlLmdyaWRBcmVhPVwicHZucGNcIjtcbnB2bnBjLnN0eWxlLmp1c3RpZnlTZWxmID0gXCJjZW50ZXJcIjtcbnB2bnBjLmNsYXNzTmFtZSA9IFwiaW4tYnV0dG9uXCI7XG5cblxuXG52aWV3LmFwcGVuZENoaWxkKHRpdGxlKTtcbnZpZXcuYXBwZW5kQ2hpbGQocHZwKTtcbnZpZXcuYXBwZW5kQ2hpbGQocHZucGMpO1xuXG5cblxuZXhwb3J0IHtcbiAgICB2aWV3LFxuICAgIGdhbWVNb2RlXG5cbn0iLCJpbXBvcnQgeyBib2R5LCBjb250YWluZXIsIHJvdXRlciB9IGZyb20gXCIuLi9kb20vbWFpbkNvbnRhaW5lclwiO1xuaW1wb3J0IHsgdmlldyBhcyBpbml0Vmlld30gZnJvbSBcIi4uL2RvbS9wcmVJbml0XCI7XG5cbmNvbnN0IHNob3dNZW51ID0gKCkgPT57XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmU9PntcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGluaXRWaWV3KTtcbiAgICAgICAgaW5pdFZpZXcuc3R5bGUuZGlzcGxheT0gJ2dyaWQnO1xuXG4gICAgICAgIGNvbnN0IG1vZGVTZWxlY3Rpb24gPSAobW9kZSk9PntcbiAgICAgICAgICAgIGluaXRWaWV3LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICByZXNvbHZlKG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwdnAnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpPT57XG4gICAgICAgICAgICBjb25zb2xlLmxvZygncHZwJyk7XG4gICAgICAgICAgICBtb2RlU2VsZWN0aW9uKCdwdnAnKVxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3B2bnBjJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKT0+e1xuICAgICAgICAgICAgY29uc29sZS5sb2coYHB2bnBjYClcbiAgICAgICAgICAgIG1vZGVTZWxlY3Rpb24oJ3B2bnBjJylcbiAgICAgICAgfSk7XG4gICAgfSlcbn1cblxuZXhwb3J0e1xuICAgIHNob3dNZW51LFxufSIsImltcG9ydCB7IGFkZEV2ZW50TGlzdGVuZXJUb2NlbGxzICwgcmVzZXRGbGVldH0gZnJvbSBcIi4uL2ZsZWV0U2V0dXBcIjtcbmltcG9ydCB7IG5leHQgfSBmcm9tIFwiLi4vZmxlZXRTZXR1cFwiO1xuaW1wb3J0IHsgdmlldyBhcyBmbGVldFNldFZpZXcgfSBmcm9tIFwiLi4vZG9tL3NldEZsZWV0XCI7XG5pbXBvcnQgeyBjb250YWluZXIgfSBmcm9tIFwiLi4vZG9tL21haW5Db250YWluZXJcIjtcbmNvbnN0IGZsZWV0UGxhY2VtZW50ID0gYXN5bmMgKHBsYXllckEscGxheWVyQiwgbW9kZSk9PntcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgcmVzb2x2ZSA9PiB7ICAgIFxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZmxlZXRTZXRWaWV3KTtcbiAgICAgICAgZmxlZXRTZXRWaWV3LnN0eWxlLmRpc3BsYXkgPSAnZ3JpZCc7XG5cbiAgICAgICAgaWYobW9kZSA9PT0gJ3B2bnBjJyl7XG4gICAgICAgICAgICByZXNldEZsZWV0KCk7XG4gICAgICAgICAgICBwbGF5ZXJCLmdlbkZsZWV0KCk7XG4gICAgICAgICAgICBhd2FpdCBzZXR1cFBsYXllckZsZWV0KHBsYXllckEsICdGaW5hbGl6ZSBwbGF5ZXIgQScpO1xuICAgICAgICAgICAgZmxlZXRTZXRWaWV3LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH07XG4gICAgICAgIGlmKG1vZGUgPT09ICdwdnAnKXtcbiAgICAgICAgICAgIHJlc2V0RmxlZXQoKTtcbiAgICAgICAgICAgIGF3YWl0IHNldHVwUGxheWVyRmxlZXQocGxheWVyQSwgJ0ZpbmFsaXplIHBsYXllciBBJyk7XG4gICAgICAgICAgICByZXNldEZsZWV0KCk7XG4gICAgICAgICAgICBhd2FpdCBzZXR1cFBsYXllckZsZWV0KHBsYXllckIsICdGaW5hbGl6ZSBwbGF5ZXIgQicpO1xuICAgICAgICAgICAgZmxlZXRTZXRWaWV3LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH07XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbn07XG5jb25zdCBzZXR1cFBsYXllckZsZWV0ID0gYXN5bmMgKHBsYXllciwgbmV4dEJ0bik9PntcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PntcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lclRvY2VsbHMocGxheWVyKTtcbiAgICAgICAgbmV4dC5pbm5lckhUTUwgPSBuZXh0QnRuO1xuXG4gICAgICAgIGlmKCFmbGVldFNldFZpZXcuY29udGFpbnMobmV4dCkpe1xuICAgICAgICAgICAgZmxlZXRTZXRWaWV3LmFwcGVuZENoaWxkKG5leHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsKCk9PntcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBuZXh0IGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkIWApO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LHtvbmNlOnRydWV9KTtcbiAgICAgIFxuICAgIH0pXG59XG4gZXhwb3J0e1xuICAgIGZsZWV0UGxhY2VtZW50XG4gICAgfSIsImltcG9ydCB7IGNyZWF0ZUJvYXJkIH0gZnJvbSBcIi4vZ3JpZFwiO1xuY29uc3QgdmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xudmlldy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG52aWV3LnN0eWxlLmFsaWduU2VsZiA9IFwiY2VudGVyXCI7XG52aWV3LnN0eWxlLmp1c3RpZnlTZWxmID0gXCJjZW50ZXJcIjtcbnZpZXcuc3R5bGUuZGlzcGxheSA9IFwiZ3JpZFwiO1xudmlldy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG52aWV3LnN0eWxlLndpZHRoID0gJzEwMCUnO1xudmlldy5zdHlsZS5ncmlkVGVtcGxhdGVDb2x1bW5zID0gXCIxZnIgIDFmclwiO1xudmlldy5zdHlsZS5ncmlkVGVtcGxhdGVSb3dzID0gXCIxZnIgNGZyIDFmclwiO1xudmlldy5zdHlsZS5ncmlkVGVtcGxhdGVBcmVhcyA9IGBcblwidGl0bGUgICB0aXRsZSBcIlxuXCIgY29udGFpbmVyQSBjb250YWluZXJCIFwiXG5cImNvbnRhaW5lckEgY29udGFpbmVyQiAgXCJgXG5cbmNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG50aXRsZS5zdHlsZS5ncmlkQXJlYSA9IFwidGl0bGVcIjtcbi8vdGl0bGUuaW5uZXJIVE1MID0gXCJjb29yZGluYXRlIGF0dGFjayFcIjtcbnRpdGxlLnN0eWxlLmFsaWduU2VsZiA9IFwiY2VudGVyXCI7XG50aXRsZS5zdHlsZS5qdXN0aWZ5U2VsZiA9IFwiY2VudGVyXCI7XG5cbi8vY3JlYXRlIGdyaWRBIGFuZCBncmlkIEJcbmNvbnN0IHtncmlkIDogZ3JpZEEsY2VsbHMgOiBjZWxsc0F9ID0gY3JlYXRlQm9hcmQoJ3BsYXllckEnKTtcbmNvbnN0IHtncmlkIDogZ3JpZEIsY2VsbHMgOiBjZWxsc0IgfT0gY3JlYXRlQm9hcmQoJ3BsYXllckInKTtcblxuZ3JpZEEuc3R5bGUuZ3JpZEFyZWEgPSAnZ3JpZEEnO1xuZ3JpZEIuc3R5bGUuZ3JpZEFyZWEgPSdncmlkQic7XG4vL2dyaWQgQSBjb250YWluZXJcbmNvbnN0IGdyaWRBQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5ncmlkQUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2dyaWQnO1xuZ3JpZEFDb250YWluZXIuc3R5bGUuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IFwiMWZyXCI7XG5ncmlkQUNvbnRhaW5lci5zdHlsZS5ncmlkVGVtcGxhdGVSb3dzID0gXCIxZnIgNmZyXCI7XG5ncmlkQUNvbnRhaW5lci5zdHlsZS5ncmlkVGVtcGxhdGVBcmVhcyA9IGBcblwiZ3JpZE5hbWVBIFwiXG5cIiBncmlkQSBcImBcbmdyaWRBQ29udGFpbmVyLnN0eWxlLmdyaWRBcmVhID0gJ2NvbnRhaW5lckEnO1xuLy8gZ3JpZCBBIG5hbWVcbmNvbnN0IGdyaWRBTmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuZ3JpZEFOYW1lLmlubmVySFRNTCA9IGdyaWRBLmlkO1xuZ3JpZEFOYW1lLnN0eWxlLmdyaWRBcmVhID0gJ2dyaWROYW1lQSc7XG5ncmlkQU5hbWUuc3R5bGUuYWxpZ25TZWxmID0gJ2NlbnRlcic7XG5ncmlkQU5hbWUuc3R5bGUuanVzdGlmeVNlbGYgPSAnY2VudGVyJztcbi8vY2VudGVyaW5nIGNvbnRhaW5lciB0aXRsZSBhbmQgYm9hcmRcbi8vdGl0bGVcbmdyaWRBTmFtZS5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcic7XG5ncmlkQU5hbWUuc3R5bGUuanVzdGlmeUl0ZW1zID0gJ2NlbnRlcic7XG4vL2JvYXJkXG5ncmlkQUNvbnRhaW5lci5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcic7XG5ncmlkQUNvbnRhaW5lci5zdHlsZS5qdXN0aWZ5SXRlbXMgPSAnY2VudGVyJztcblxuZ3JpZEFDb250YWluZXIuYXBwZW5kQ2hpbGQoZ3JpZEFOYW1lKVxuZ3JpZEFDb250YWluZXIuYXBwZW5kQ2hpbGQoZ3JpZEEpXG5cbi8vZ3JpZCBCIGNvbnRhaW5lclxuY29uc3QgZ3JpZEJDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbmdyaWRCQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnZ3JpZCc7XG5ncmlkQkNvbnRhaW5lci5zdHlsZS5ncmlkVGVtcGxhdGVDb2x1bW5zID0gXCIxZnJcIjtcbmdyaWRCQ29udGFpbmVyLnN0eWxlLmdyaWRUZW1wbGF0ZVJvd3MgPSBcIjFmciA2ZnJcIjtcbmdyaWRCQ29udGFpbmVyLnN0eWxlLmdyaWRUZW1wbGF0ZUFyZWFzID0gYFxuXCJncmlkTmFtZUIgXCJcblwiIGdyaWRCIFwiYFxuZ3JpZEJDb250YWluZXIuc3R5bGUuZ3JpZEFyZWEgPSAnY29udGFpbmVyQic7XG4vLyBncmlkIGIgbmFtZVxuY29uc3QgZ3JpZEJOYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5ncmlkQk5hbWUuaW5uZXJIVE1MID0gZ3JpZEIuaWQ7XG5ncmlkQk5hbWUuc3R5bGUuZ3JpZEFyZWEgPSAnZ3JpZE5hbWVCJztcbmdyaWRCTmFtZS5zdHlsZS5hbGlnblNlbGYgPSAnY2VudGVyJztcbmdyaWRCTmFtZS5zdHlsZS5qdXN0aWZ5U2VsZiA9ICdjZW50ZXInO1xuLy9jZW50ZXJpbmcgY29udGFpbmVyIHRpdGxlIGFuZCBib2FyZFxuLy90aXRsZVxuZ3JpZEJOYW1lLnN0eWxlLmFsaWduSXRlbXMgPSAnY2VudGVyJztcbmdyaWRCTmFtZS5zdHlsZS5qdXN0aWZ5SXRlbXMgPSAnY2VudGVyJztcbi8vYm9hcmRcbmdyaWRCQ29udGFpbmVyLnN0eWxlLmFsaWduSXRlbXMgPSAnY2VudGVyJztcbmdyaWRCQ29udGFpbmVyLnN0eWxlLmp1c3RpZnlJdGVtcyA9ICdjZW50ZXInO1xuXG5ncmlkQkNvbnRhaW5lci5hcHBlbmRDaGlsZChncmlkQk5hbWUpXG5ncmlkQkNvbnRhaW5lci5hcHBlbmRDaGlsZChncmlkQilcblxuXG5cblxuXG5cbnZpZXcuYXBwZW5kQ2hpbGQoZ3JpZEFDb250YWluZXIpO1xudmlldy5hcHBlbmRDaGlsZChncmlkQkNvbnRhaW5lcik7XG5cblxudmlldy5hcHBlbmRDaGlsZCh0aXRsZSk7XG5cblxuZXhwb3J0IHtcbiAgICB2aWV3LFxuICAgIGdyaWRBLFxuICAgIGdyaWRCLFxuICAgIHRpdGxlXG59IiwiaW1wb3J0IHsgdmlldyBhcyBhdHRhY2tWaWV3LCB0aXRsZSwgZ3JpZEEsIGdyaWRCfSBmcm9tIFwiLi4vZG9tL0F0dGFja1wiO1xuaW1wb3J0IHtjb250YWluZXIgfSBmcm9tIFwiLi4vZG9tL21haW5Db250YWluZXJcIlxuaW1wb3J0IHsgU2hpcCB9IGZyb20gXCIuLi9sb2dpYy9TaGlwXCI7XG5cblxuXG5jb25zdCBiYXR0bGU9IGFzeW5jIChwbGF5ZXJBLHBsYXllckIsIG1vZGUpPT57XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGF0dGFja1ZpZXcpO1xuXG4gICAgXG4gICAgaWYobW9kZSA9PT0gJ3B2bnBjJyl7XG4gICAgICAgIGNvbnN0IHdpbm5lciA9IGF3YWl0IGhhbmRsZVB2TnBjKHBsYXllckEsIHBsYXllckIpO1xuICAgICAgICBpZih3aW5uZXIpe1xuICAgICAgICAgICAgcmVzZXRHcmlkcyhncmlkQSwgcGxheWVyQS5nYW1lYm9hcmQuZ2V0R3JpZCgpKTtcbiAgICAgICAgICAgIHJlc2V0R3JpZHMoZ3JpZEIsIHBsYXllckIuZ2FtZWJvYXJkLmdldEdyaWQoKSk7XG4gICAgICAgICAgICBhdHRhY2tWaWV3LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHJldHVybiB3aW5uZXJcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICB9XG5cbn1cbmNvbnN0IGhhbmRsZVB2TnBjID0gYXN5bmMgKHBsYXllckEsIHBsYXllckIpPT57XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIHJlc29sdmUgPT57XG4gICAgICAgIGF0dGFja1ZpZXcuc3R5bGUuZGlzcGxheSA9IFwiZ3JpZFwiO1xuICAgICAgICBsZXQgc3RhZ2UgPSAnYXR0YWNrJztcbiAgICAgICAgbGV0IHdpbm5lciA9IGZhbHNlO1xuICAgICAgICBhZGRBdHRhY2tFdmVudExpc3RlbmVyKHBsYXllckIsIGdyaWRCKTtcblxuXG4gICAgICAgIHdoaWxlKCF3aW5uZXIpe1xuICAgICAgICAgICAgaWYoc3RhZ2UgPT09ICdhdHRhY2snKXtcbiAgICAgICAgICAgICAgICAvL3BsYXllciBhdHRhY2tzXG4gICAgICAgICAgICAgICAgdGl0bGUuaW5uZXJIVE1MID1cIllvdXIgdHVybiB0byBhdHRhY2shXCI7XG4gICAgICAgICAgICAgICAgLy9ncmlkQS5zdHlsZS5vdXRsaW5lID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgLy9ncmlkQS5zdHlsZS5vdXRsaW5lT2Zmc2V0ID0gJzBweCc7XG5cblxuICAgICAgICAgICAgICAgIC8vZ3JpZEIuc3R5bGUudHJhbnNmb3JtPSBcInNjYWxlKDEpXCI7XG4gICAgICAgICAgICAgICAgLy9ncmlkQi5zdHlsZS50cmFuc2l0aW9uID1cInRyYW5zZm9ybSAwLjJzIGVhc2UsIG91dGxpbmUgMC4ycyBlYXNlXCI7XG4gICAgICAgICAgICAgICAgZ3JpZEEuY2xhc3NMaXN0LnJlbW92ZSgndW5kZXItYXR0YWNrJyk7XG4gICAgICAgICAgICAgICAgZ3JpZEIuY2xhc3NMaXN0LnJlbW92ZSgnYXR0YWNraW5nJyk7XG5cbiAgICAgICAgICAgICAgICBncmlkQS5jbGFzc0xpc3QuYWRkKCdhdHRhY2tpbmcnKVxuICAgICAgICAgICAgICAgIGdyaWRCLmNsYXNzTGlzdC5hZGQoJ3VuZGVyLWF0dGFjaycpO1xuXG4gICAgICAgICAgICAgICAgLy9ncmlkQi5zdHlsZS5vdXRsaW5lID0gXCIycHggc29saWQgYmxhY2tcIjtcbiAgICAgICAgICAgICAgICAvL2dyaWRCLnN0eWxlLm91dGxpbmVPZmZzZXQgPSAnLTJweCc7XG5cbiAgICAgICAgICAgICAgICBkaXNwbGF5UGxheWVyR3JpZChwbGF5ZXJBLmdhbWVib2FyZC5nZXRHcmlkKCksZ3JpZEEpO1xuXG4gICAgICAgICAgICAgICAgdG9nZ2xlRXZlbnRMaXN0ZW5lcihncmlkQSxwbGF5ZXJBLmdhbWVib2FyZC5nZXRHcmlkKCksICdub25lJyk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlRXZlbnRMaXN0ZW5lcihncmlkQixwbGF5ZXJCLmdhbWVib2FyZC5nZXRHcmlkKCksICdhdXRvJyk7XG5cblxuICAgICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JBdHRhY2soZ3JpZEIsIHBsYXllckIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmU9PiB7c2V0VGltZW91dChyZXNvbHZlLCA1MDApfSk7IFxuXG4gICAgICAgICAgICAgICAgaWYocGxheWVyQi5nYW1lYm9hcmQuYWxsU2hpcHNTdW5rKCkpe1xuICAgICAgICAgICAgICAgICAgICB3aW5uZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aXRsZS5pbm5lckhUTUwgPVwieW91IGFyZSB0aGUgd2lubmVyXCI7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJ1BsYXllckEnKVxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBzdGFnZSA9ICdvYnNlcnZlJzsgIFxuICAgICAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHN0YWdlID09PSAnb2JzZXJ2ZScpe1xuXG4gICAgICAgICAgICAgICAgLy9jb21wdXRlciBhdHRhY2tzXG4gICAgICAgICAgICAgICAgdGl0bGUuaW5uZXJIVE1MID1cIkNvbXB1dGVycyB0dXJuIHRvIGF0dGFjayFcIjtcbiAgICAgICAgICAgICAgICAvL2dyaWRCLnN0eWxlLm91dGxpbmUgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAvL2dyaWRCLnN0eWxlLm91dGxpbmVPZmZzZXQgPSAnMHB4JztcbiAgICAgICAgICAgICAgICBncmlkQi5jbGFzc0xpc3QucmVtb3ZlKCd1bmRlci1hdHRhY2snKTtcbiAgICAgICAgICAgICAgICBncmlkQS5jbGFzc0xpc3QucmVtb3ZlKCdhdHRhY2tpbmcnKTtcblxuICAgICAgICAgICAgICAgIGdyaWRCLmNsYXNzTGlzdC5hZGQoJ2F0dGFja2luZycpXG4gICAgICAgICAgICAgICAgZ3JpZEEuY2xhc3NMaXN0LmFkZCgndW5kZXItYXR0YWNrJyk7XG4gICAgICAgICAgICAgICAvL2dyaWRBLnN0eWxlLm91dGxpbmUgPSBcIjJweCBzb2xpZCBibGFja1wiO1xuICAgICAgICAgICAgICAgIC8vZ3JpZEEuc3R5bGUub3V0bGluZU9mZnNldCA9ICctMnB4JztcblxuXG4gICAgICAgICAgICAgICAgdG9nZ2xlRXZlbnRMaXN0ZW5lcihncmlkQSxwbGF5ZXJBLmdhbWVib2FyZC5nZXRHcmlkKCksICdub25lJyk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlRXZlbnRMaXN0ZW5lcihncmlkQixwbGF5ZXJCLmdhbWVib2FyZC5nZXRHcmlkKCksICdub25lJyk7XG5cbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlPT4ge3NldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCl9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCB3YWl0Q29tcHV0ZXJBdHRhY2socGxheWVyQiwgcGxheWVyQSwgZ3JpZEEpIFxuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmU9PiB7c2V0VGltZW91dChyZXNvbHZlLCA1MDApfSk7ICBcblxuICAgICAgICAgICAgaWYocGxheWVyQS5nYW1lYm9hcmQuYWxsU2hpcHNTdW5rKCkpe1xuICAgICAgICAgICAgICAgICAgICB3aW5uZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aXRsZS5pbm5lckhUTUwgPVwiY29tcHV0ZXIgaGFzIHdvblwiO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCdQbGF5ZXJCJylcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgc3RhZ2UgPSAnYXR0YWNrJzsgIFxuICAgICAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuIFxuICAgIH0pXG5cbn1cbi8vdWkgdXBkYXRlcnNcbmNvbnN0IGRpc3BsYXlQbGF5ZXJHcmlkID0gKHBsYXllckdyaWQgLCB1aUdhbWVib2FyZCk9PntcbiAgICBwbGF5ZXJHcmlkLmZvckVhY2goKGxvZ2ljUm93LCB5SW5kZXgpID0+e1xuICAgICAgICBsb2dpY1Jvdy5mb3JFYWNoKChsb2dpY0NlbGwsIHhJbmRleCkgPT57XG4gICAgICAgICAgICBpZihsb2dpY0NlbGwgaW5zdGFuY2VvZiBTaGlwKXtcbiAgICAgICAgICAgICAgICAvL2dldCBkb20gY2VsbHMgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3QgbG9naWNDZWxsSWQgPSBgJHt4SW5kZXh9LCR7eUluZGV4fWAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbHMgPSB1aUdhbWVib2FyZC5xdWVyeVNlbGVjdG9yQWxsKCcuY2VsbCcpO1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgc2hpcCBwbGFjZW1lbnQgaW4gdGhlIGdhbWVib2FyZCAyRGFycmF5XG4gICAgICAgICAgICAgICAgY2VsbHMuZm9yRWFjaChjZWxsPT57XG4gICAgICAgICAgICAgICAgICAgIGlmKGNlbGwuaWQgPT09IGxvZ2ljQ2VsbElkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dpY0NlbGwgPT09IFwiaGl0XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNlIGlmKCBsb2dpY0NlbGwgPT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdncmF5J1xuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2UgaWYobG9naWNDZWxsIGluc3RhbmNlb2YgU2hpcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiM2Y2YxZTZmZlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9KVxuICAgIH0pXG5cbn1cbi8vYXN5bmNyb251cyBhdHRhY2tzXG5jb25zdCB3YWl0Rm9yQXR0YWNrID0gKGdyaWQsIHBsYXllcikgPT57XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCBwbGF5ZXJHcmlkID0gcGxheWVyLmdhbWVib2FyZC5ncmlkO1xuICAgICAgICBjb25zdCBjZWxscyA9IGdyaWQucXVlcnlTZWxlY3RvckFsbCgnLmNlbGwnKTtcbiAgXG4gICAgICAgIGNvbnN0IGludmFsaWRDZWxscyA9IFtdO1xuICAgICAgICBjZWxscy5mb3JFYWNoKGNlbGw9PntcbiAgICAgICAgICAgIGNvbnN0IFt5LCB4XSA9IGNlbGwuaWQuc3BsaXQoJywnKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgICAgIGlmKHBsYXllckdyaWRbeF1beV0gPT09IGZhbHNlIHx8IHBsYXllckdyaWRbeF1beV0gPT09ICdoaXQnKXtcbiAgICAgICAgICAgICAgICBpbnZhbGlkQ2VsbHMucHVzaChjZWxsKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlQ2VsbENsaWNrKGUpe1xuICAgICAgICAgICAgY29uc3QgY2VsbCA9IGUudGFyZ2V0LmNsb3Nlc3QoJy5jZWxsJyk7XG4gICAgICAgICAgICBjb25zdCBbeSwgeF0gPSBjZWxsLmlkLnNwbGl0KCcsJykubWFwKE51bWJlcik7XG5cbiAgICAgICAgICAgIGludmFsaWRDZWxscy5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgcmVzb2x2ZShjZWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjZWxscy5mb3JFYWNoKGNlbGw9PntcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIWludmFsaWRDZWxscy5pbmNsdWRlcyhjZWxsKSB8fCAhY2VsbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtbGlzdGVuZXItYWRkZWQnKSl7ICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICBjZWxsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxoYW5kbGVDZWxsQ2xpY2sse29uY2U6dHJ1ZX0pO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSlcbn1cbi8vY29tcHV0ZXIgYXR0YWNrXG5jb25zdCB3YWl0Q29tcHV0ZXJBdHRhY2sgPWFzeW5jKHBsYXllciwgb3Bwb25lbnQsIGdyaWQpPT57XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmU9PiB7XG4gICAgICAgIGNvbnN0IHsgaGl0LCB4LCB5fSA9IHBsYXllci5haUF0dGFjayhvcHBvbmVudCk7XG4gICAgICAgIGNvbnN0IGNlbGxJZCA9IGAke3h9LCR7eX1gXG4gICAgICAgIGxldCBjZWxsO1xuICAgICAgICBjb25zdCBjZWxscyA9IGdyaWQucXVlcnlTZWxlY3RvckFsbCgnLmNlbGwnKTtcbiAgICAgICAgY2VsbHMuZm9yRWFjaChpdGVtPT57XG4gICAgICAgICAgICBpZiAoaXRlbS5pZCA9PT0gY2VsbElkKSB7XG4gICAgICAgICAgICAgICAgY2VsbCA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgaWYoY2VsbCl7XG4gICAgICAgICAgICBpZihoaXQpe1xuXG4gICAgICAgICAgICAgICAgY2VsbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJlZFwiO1xuICAgICAgICAgICAgICAgIGNlbGwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgICAgICBjZWxsLnN0eWxlLm9wYWNpdHkgPSAnMC41JzsgICAgICAgXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNlbGwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgICAgICBjZWxsLnN0eWxlLm9wYWNpdHkgPScwLjUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ICBlbHNle1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgY2VsbCB3aXRoIGlkICR7Y2VsbElkfSBub3QgZm91bmRgKVxuICAgICAgICB9IFxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgIFxuICAgIH0pXG59IFxuLy9oYW5kbGVzIGV2ZW50IGxpc3RlbmVyc1xuY29uc3QgdG9nZ2xlRXZlbnRMaXN0ZW5lcj0oZ3JpZCxwbGF5ZXJHcmlkLCBzdGF0ZSk9PntcbiAgICBjb25zdCBjZWxscyA9IGdyaWQucXVlcnlTZWxlY3RvckFsbCgnLmNlbGwnKTtcblxuICAgIGNlbGxzLmZvckVhY2goY2VsbD0+e1xuICAgICAgICBjb25zdCBbeSwgeF0gPSBjZWxsLmlkLnNwbGl0KCcsJykubWFwKE51bWJlcik7XG4gICAgICAgIFxuICAgICAgICBpZihwbGF5ZXJHcmlkW3hdW3ldID09PSBmYWxzZSB8fCBwbGF5ZXJHcmlkW3hdW3ldID09PSBcImhpdFwiKXtcbiAgICAgICAgICAgIGNlbGwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIGNlbGwuc3R5bGUub3BhY2l0eSA9ICcwLjUnO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGNlbGwuc3R5bGUucG9pbnRlckV2ZW50cyA9IHN0YXRlO1xuICAgICAgICB9XG4gICAgfSlcblxufVxuLy9hcHBlbmRzIGV2ZW50IGxpc3RlbmVycyB0byBjZWxsc1xuY29uc3QgYWRkQXR0YWNrRXZlbnRMaXN0ZW5lciA9IChwbGF5ZXIsIGdyaWQpPT57XG4gICAgY29uc3QgY2VsbHMgPSBncmlkLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jZWxsJylcblxuICAgIGNvbnN0IGNsaWNrTGlzdGVuZXIgPSAoZSkgPT57XG4gICAgICAgIGNvbnN0IGNlbGwgPSBlLnRhcmdldC5jbG9zZXN0KCcuY2VsbCcpO1xuICAgICAgICBpZighY2VsbCkgcmV0dXJuO1xuICAgICAgICBjbGlja0hhbmRsZXIocGxheWVyLmdhbWVib2FyZCwgY2VsbClcblxuICAgIH1cblxuICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PntcbiAgICAgICAgaWYoIWNlbGwuaGFzQXR0cmlidXRlKCdkYXRhLWxpc3RlbmVyLWFkZGVkJykpe1xuXG4gICAgICAgICAgICBjZWxsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsKCk9PntcbiAgICAgICAgICAgIGNlbGwuc3R5bGUub3V0bGluZSA9ICcycHggc29saWQgZ3JlZW4nO1xuICAgICAgICAgICAgY2VsbC5zdHlsZS5vdXRsaW5lT2Zmc2V0ID0gJy0ycHgnO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBjZWxsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywoKT0+e1xuICAgICAgICAgICAgY2VsbC5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xuICAgICAgICAgICAgY2VsbC5zdHlsZS5vdXRsaW5lT2Zmc2V0ID0gJzBweCc7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGNlbGwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIGNlbGwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGlja0xpc3RlbmVyLHtvbmNlOnRydWV9KTtcbiAgICAgICAgICAgIGNlbGwuc2V0QXR0cmlidXRlKCdkYXRhLWxpc3RlbmVyLWFkZGVkJywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgIH0pXG5cbn1cbi8vaGFuZGVscyBldmVudCBsaXN0ZW5lciBvbmNsaWNrXG5jb25zdCBjbGlja0hhbmRsZXI9KHBsYXllckdyaWQsY2VsbCk9PntcbiBcbiAgICBjb25zdCBbeSwgeF0gPSBjZWxsLmlkLnNwbGl0KCcsJykubWFwKE51bWJlcik7XG5cbiAgICBsZXQgaGl0U3RhdHVzO1xuICAgIGlmICggTnVtYmVyLmlzTmFOKHgpIHx8IE51bWJlci5pc05hTih5KSB8fCB5IDwgMCB8fCB5ID4gOSB8fCB4IDwgMCB8fCB4ID4gOSB8fHBsYXllckdyaWQuZ3JpZFt4XVt5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgY29vcmRpbmF0ZXM6ICgke3h9LCAke3l9KWApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmKHBsYXllckdyaWQuZ3JpZFt4XVt5XSA9PT0gZmFsc2UgfHwgcGxheWVyR3JpZC5ncmlkW3hdW3ldID09PSAnaGl0Jyl7XG4gICAgICAgIGNvbnNvbGUud2FybihgQ2VsbCAoJHt4fSwgJHt5fSkgaGFzIGFscmVhZHkgYmVlbiBhdHRhY2tlZC5gKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICAgIFxuICAgIH1cbiAgICBcbiAgICBpZihwbGF5ZXJHcmlkLmdyaWRbeF1beV0gaW5zdGFuY2VvZiBTaGlwIHx8IHBsYXllckdyaWQuZ3JpZFt4XVt5XSA9PT0gbnVsbCApe1xuICAgICAgICBoaXRTdGF0dXMgPSAgcGxheWVyR3JpZC5yZWNpZXZlQXR0YWNrKFt5LCB4XSk7XG4gICAgfVxuXG4gICAgXG4gICAgaWYoaGl0U3RhdHVzKXsgIFxuICAgICAgICAvL2hpdCAgICAgICAgIFxuICAgICAgICBjZWxsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiYmxhY2tcIjtcbiAgICAgICAgY2VsbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICBjZWxsLnN0eWxlLm9wYWNpdHk9JzAuNSc7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgIH1lbHNlIGlmKCFoaXRTdGF0dXMpe1xuICAgICAgICAvL21pc3NcbiAgICAgICAgY2VsbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICBjZWxsLnN0eWxlLm9wYWNpdHkgPSAnMC41JzsgICAgICBcbiAgICB9XG5cbiAgICByZXR1cm5cbiAgICBcblxufVxuLy9yZXNldGluZyBnYW1lYmFvcmRcbmNvbnN0IHJlc2V0R3JpZHMgPSAoZ3JpZCwgcGxheWVyR3JpZCkgPT57XG4gICAgY29uc3QgY2VsbHMgPSBncmlkLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jZWxsJyk7XG4gICAgY2VsbHMuZm9yRWFjaChjZWxsPT57XG4gICAgICAgIGNvbnN0IFt5LCB4XSA9IGNlbGwuaWQuc3BsaXQoJywnKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgcGxheWVyR3JpZFt4XVt5XSA9IG51bGxcbiAgICAgICAgY29uc3QgY2xvbmUgPSBjZWxsLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgY2VsbC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjbG9uZSxjZWxsKVxuICAgICAgICBjZWxsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYXV0byc7XG4gICAgICAgIGNlbGwuc3R5bGUub3BhY2l0eSA9ICcxJztcbiAgICAgICAgY2VsbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnJztcbiAgICB9KVxufVxuXG5leHBvcnR7XG4gICAgYmF0dGxlXG59IiwiaW1wb3J0IHsgYm9keSwgY29udGFpbmVyLCByb3V0ZXIgfSBmcm9tIFwiLi4vZG9tL21haW5Db250YWluZXJcIjtcblxuY29uc3Qgc2hvd0VuZCA9IGFzeW5jICh3aW5uZXIpPT57XG4gICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgdGhlIHdpbm5lciBpczogJHt0eXBlb2Ygd2lubmVyfWApO1xuICAgICAgY29uc3QgY29uZ3JhdHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGlmKHdpbm5lciA9PT0gJ1BsYXllckEnKXtcbiAgICAgICAgIGNvbmdyYXRzLmlubmVySFRNTCA9ICdDb25ncmF0dWxhdGlvbnMgeW91IHdvbiB0aGlzIHJvdW5kISc7XG4gICAgICB9ZWxzZSBpZih3aW5uZXIgPT09IFwiUGxheWVyQlwiKXtcbiAgICAgICAgIGNvbmdyYXRzLmlubmVySFRNTCA9ICdZb3UgZGllZCEnO1xuICAgICAgfVxuICAgICAgY29uZ3JhdHMuc3R5bGUuZGlzcGxheSA9ICdncmlkJztcbiAgICAgIGNvbmdyYXRzLnN0eWxlLmp1c3RpZnlTZWxmID0gJ2NlbnRlcic7XG4gICAgICBjb25ncmF0cy5zdHlsZS5hbGlnblNlbGYgPSAnY2VudGVyJztcbiAgICAgIC8qXG4gICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGJ1dHRvbi5pbm5lckhUTUw9IFwiTmV3IGdhbWUhXCI7XG4gICAgICBidXR0b24uc3R5bGUuanVzdGlmeVNlbGYgPSAnY2VudGVyJztcbiAgICAgIGJ1dHRvbi5zdHlsZS5hbGlnblNlbGYgPSAnY2VudGVyJztcbiAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSAnaW4tYnV0dG9uJztcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsKCk9PntcbiAgICAgICAgIGNvbmdyYXRzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgIGJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgcmVzb2x2ZSh0cnVlKVxuICAgICAgfSlcbiAgICovXG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY29uZ3JhdHMpO1xuICAgICAgXG4gICB9KVxuXG59O1xuXG5leHBvcnR7XG4gICAgc2hvd0VuZCxcbn0iLCJpbXBvcnQgeyBQbGF5ZXIgfSBmcm9tIFwiLi9sb2dpYy9QbGF5ZXJcIjtcbmltcG9ydCB7IGJvZHl9IGZyb20gXCIuL2RvbS9tYWluQ29udGFpbmVyXCI7XG5pbXBvcnQge3Jlc2V0RmxlZXQgfSBmcm9tIFwiLi9mbGVldFNldHVwXCI7XG5cbi8vaW1wb3J0IGdyaWRzXG5pbXBvcnQgeyBzaG93TWVudSB9IGZyb20gXCIuL3N0YWdlcy9tZW51U3RhZ2VcIjtcbmltcG9ydCB7IGZsZWV0UGxhY2VtZW50IH0gZnJvbSBcIi4vc3RhZ2VzL2ZsZWV0U2V0dXBTdGFnZVwiO1xuaW1wb3J0IHsgYmF0dGxlIH0gZnJvbSBcIi4vc3RhZ2VzL2JhdHRsZVN0YWdlXCI7XG5pbXBvcnQgeyBzaG93RW5kIH0gZnJvbSBcIi4vc3RhZ2VzL2VuZEdhbWVTdGFnZVwiO1xuXG5cbi8vaW5pdGlhdGVzIGdhbWUgYW5kIHByb21wdHMgZm9yIGdhbWUgbW9kZVxuY29uc3QgZ2FtZVN0YXJ0ID0gYXN5bmMgKCk9PntcbiAgIC8vPT0+bmV3IGltcGxlbWVudGF0aW9uPD09XG4gICBsZXQgcGxheUFnYWluID10cnVlO1xuICAgLy9zZXRzZ2FtZSBtb2RlXG4gICAvL2dsb2JhbCBwbGF5ZXJzOlxuIFxuICAgd2hpbGUocGxheUFnYWluKXtcbiAgICBsZXQgcGxheWVyQSA9IG51bGw7XG4gICAgbGV0IHBsYXllckIgPSBudWxsXG4gICAgY29uc3QgbW9kZSA9IGF3YWl0IHNob3dNZW51KCk7XG4gICAgLy9mbGVldCBzZXR1cFxuICAgICAgICBpZihtb2RlID09PSAncHZucGMnKXtcbiAgICAgICAgICAgIHBsYXllckEgPSBuZXcgUGxheWVyKCk7XG4gICAgICAgICAgICBwbGF5ZXJCID0gbmV3IFBsYXllcih0cnVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9ZWxzZSBpZihtb2RlID09PSAncHZwJyl7XG5cbiAgICAgICAgICAgIGFsZXJ0KGBjdXJyZW50bHkgdW5hdmFpbGFibGVgKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBmbGVldFBsYWNlbWVudChwbGF5ZXJBLCBwbGF5ZXJCLCBtb2RlKTtcbiAgICBcbiAgICAgICAgLy9iYXR0bGUgbG9vcFxuICAgICAgICBjb25zdCB3aW5uZXIgPSBhd2FpdCBiYXR0bGUocGxheWVyQSwgcGxheWVyQiwgbW9kZSk7XG4gICAgICAgIC8vZW5kXG4gICAgICAgIGNvbnN0IG5ld1JvdW5kID0gYXdhaXQgc2hvd0VuZCh3aW5uZXIpO1xuXG4gICAgICAgIC8vcHJvbXB0IG5ldyBnYW1lXG4gICAgICAgIHBsYXlBZ2FpbiA9YXdhaXQgbmV3R2FtZShuZXdSb3VuZCwgcGxheWVyQSwgcGxheWVyQik7XG4gICAgfVxuXG59XG5jb25zdCBuZXdHYW1lID0gYXN5bmMgKGlucHV0LCBwbGF5ZXJBLCBwbGF5ZXJCKSA9PntcbiAgICBpZihpbnB1dCl7XG4gICAgICAgIHBsYXllckEuZ2FtZWJvYXJkLmNsZWFyR3JpZCgpO1xuICAgICAgICBwbGF5ZXJCLmdhbWVib2FyZC5jbGVhckdyaWQoKTtcbiAgICAgICAgcmVzZXRGbGVldCgpO1xuICAgICAgICBnYW1lU3RhcnQoKTtcbiAgICB9XG59XG5cbmNvbnN0IGJhdHRsZXNoaXA9KCk9PntcblxuICAgIGJvZHlcbiAgICBnYW1lU3RhcnQoKTtcbiAgICBcbn1cblxuXG5leHBvcnQge1xuICAgIGJhdHRsZXNoaXAsXG59IiwiaW1wb3J0IHsgYmF0dGxlc2hpcCB9IGZyb20gXCIuL21vZHVsZXMvUGxheVwiO1xuaW1wb3J0IFwiLi9zdHlsZXMuY3NzXCI7XG5cblxuYmF0dGxlc2hpcCgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///523\n")}},__webpack_exports__={};__webpack_modules__[523]()})();